#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "sam.h"

static void Render();
static void SetMouthThroat(unsigned char mouth, unsigned char throat);
static void Init();
static int Parser1();
static void Parser2();
static void CopyStress();
static void SetPhonemeLength();
static void AdjustLengths();
static void Code41240();
static void Insert(unsigned char position, unsigned char mem60, unsigned char mem59, unsigned char mem58);
static void InsertBreath();
static void PrepareOutput();
static void SetMouthThroat(unsigned char mouth, unsigned char throat);

static void ProcessFrames(unsigned char mem48);
static void RenderSample(unsigned char* mem66, unsigned char consonantFlag, unsigned char mem49);
static unsigned char CreateTransitions();

#define PHONEME_PERIOD (1)
#define PHONEME_QUESTION (2)

#define RISING_INFLECTION (1)
#define FALLING_INFLECTION (255)

static unsigned char pitches[256]; // tab43008

static unsigned char frequency1[256];
static unsigned char frequency2[256];
static unsigned char frequency3[256];

static unsigned char amplitude1[256];
static unsigned char amplitude2[256];
static unsigned char amplitude3[256];

static unsigned char input[256]; // tab39445

// standard sam sound
static unsigned char speed = 72;
static unsigned char pitch = 64;
static unsigned char mouth = 128;
static unsigned char throat = 128;

unsigned char stress[256]; // numbers from 0 to 8
unsigned char phonemeLength[256]; // tab40160
unsigned char phonemeindex[256];

unsigned char phonemeIndexOutput[60]; // tab47296
unsigned char stressOutput[60]; // tab47365
unsigned char phonemeLengthOutput[60]; // tab47416

// contains the final soundbuffer
int bufferpos = 0;
char* buffer = NULL;

unsigned char sampledConsonantFlag[256]; // tab44800

unsigned char tab48426[5] = { 0x18, 0x1A, 0x17, 0x17, 0x17 };

unsigned char tab47492[] = 
{
	0 , 0 , 0xE0 , 0xE6 , 0xEC , 0xF3 , 0xF9 , 0 , 
	6 , 0xC , 6
};


unsigned char amplitudeRescale[] = 
{
	0 , 1 , 2 , 2 , 2 , 3 , 3 , 4 ,
	4 , 5 , 6 , 8 , 9 ,0xB ,0xD ,0xF, 0  //17 elements?
};

// Used to decide which phoneme's blend lengths. The candidate with the lower score is selected.
// tab45856 
unsigned char blendRank[] = 
{
	0 , 0x1F , 0x1F , 0x1F , 0x1F , 2 , 2 , 2 ,
	2 , 2 , 2 , 2 , 2 , 2 , 5 , 5 ,
	2 ,0xA , 2 , 8 , 5 , 5 ,0xB ,0xA ,
	9 , 8 , 8 , 0xA0 , 8 , 8 , 0x17 , 0x1F ,
	0x12 , 0x12 , 0x12 , 0x12 , 0x1E , 0x1E , 0x14 , 0x14 ,
	0x14 , 0x14 , 0x17 , 0x17 , 0x1A , 0x1A , 0x1D , 0x1D ,
	2 , 2 , 2 , 2 , 2 , 2 , 0x1A , 0x1D ,
	0x1B , 0x1A , 0x1D , 0x1B , 0x1A , 0x1D , 0x1B , 0x1A ,
	0x1D , 0x1B , 0x17 , 0x1D , 0x17 , 0x17 , 0x1D , 0x17 ,
	0x17 , 0x1D , 0x17 , 0x17 , 0x1D , 0x17 , 0x17 , 0x17
};


// Number of frames at the end of a phoneme devoted to interpolating to next phoneme's final value
//tab45696
unsigned char outBlendLength[] = 
{
	0 , 2 , 2 , 2 , 2 , 4 , 4 , 4 ,
	4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 ,
	4 , 4 , 3 , 2 , 4 , 4 , 2 , 2 ,
	2 , 2 , 2 , 1 , 1 , 1 , 1 , 1 ,
	1 , 1 , 1 , 1 , 1 , 1 , 2 , 2 ,
	2 , 1 , 0 , 1 , 0 , 1 , 0 , 5 ,
	5 , 5 , 5 , 5 , 4 , 4 , 2 , 0 ,
	1 , 2 , 0 , 1 , 2 , 0 , 1 , 2 ,
	0 , 1 , 2 , 0 , 2 , 2 , 0 , 1 ,
	3 , 0 , 2 , 3 , 0 , 2 , 0xA0 , 0xA0
};


// Number of frames at beginning of a phoneme devoted to interpolating to phoneme's final value
// tab45776
unsigned char inBlendLength[] = 
{
	0 , 2 , 2 , 2 , 2 , 4 , 4 , 4 ,
	4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 ,
	4 , 4 , 3 , 3 , 4 , 4 , 3 , 3 ,
	3 , 3 , 3 , 1 , 2 , 3 , 2 , 1 ,
	3 , 3 , 3 , 3 , 1 , 1 , 3 , 3 ,
	3 , 2 , 2 , 3 , 2 , 3 , 0 , 0 ,
	5 , 5 , 5 , 5 , 4 , 4 , 2 , 0 ,
	2 , 2 , 0 , 3 , 2 , 0 , 4 , 2 ,
	0 , 3 , 2 , 0 , 2 , 2 , 0 , 2 ,
	3 , 0 , 3 , 3 , 0 , 3 , 0xB0 , 0xA0 
};


// Looks like it's used as bit flags
// High bits masked by 248 (11111000)
//
// 32: S*    241         11110001
// 33: SH    226         11100010    
// 34: F*    211         11010011
// 35: TH    187         10111011
// 36: /H    124         01111100
// 37: /X    149         10010101
// 38: Z*    1           00000001
// 39: ZH    2           00000010
// 40: V*    3           00000011
// 41: DH    3           00000011
// 43: **    114         01110010
// 45: **    2           00000010
// 67: **    27          00011011
// 70: **    25          00011001
// tab45936
unsigned char sampledConsonantFlags[] =
{
    0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
    0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
    0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
    0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
    0xF1 , 0xE2 , 0xD3 , 0xBB , 0x7C , 0x95 , 1 , 2 ,
    3 , 3 , 0 , 0x72 , 0 , 2 , 0 , 0 ,
    0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
    0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
    0 , 0 , 0 , 0x1B , 0 , 0 , 0x19 , 0 ,
    0 , 0 , 0 , 0 , 0 , 0 , 0 , 0
};


//tab45056
unsigned char freq1data[]=
{
	0x00 ,0x13 ,0x13 ,0x13 ,0x13 , 0xA , 0xE ,0x12
	,  0x18 ,0x1A ,0x16 ,0x14 ,0x10 ,0x14 , 0xE ,0x12
	,	0xE ,0x12 ,0x12 ,0x10 , 0xC , 0xE , 0xA ,0x12
	,	0xE ,0xA  , 8  , 6  , 6  ,  6 ,  6 ,0x11
	,	 6 , 6 , 6 , 6 ,0xE , 0x10 , 9 ,0xA
	,	 8 ,0xA , 6 , 6 , 6 , 5 , 6 , 0
	,  0x12 , 0x1A , 0x14 , 0x1A , 0x12 ,0xC , 6 , 6
	,	 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6
	,	 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6
	,	 6 ,0xA ,0xA , 6 , 6 , 6 , 0x2C , 0x13
};

//tab451356
unsigned char freq2data[]=
{
	0x00 , 0x43 , 0x43 , 0x43 , 0x43 , 0x54 , 0x48 , 0x42 ,
	0x3E , 0x28 , 0x2C , 0x1E , 0x24 , 0x2C , 0x48 , 0x30 ,
	0x24 , 0x1E , 0x32 , 0x24 , 0x1C , 0x44 , 0x18 , 0x32 ,
	0x1E , 0x18 , 0x52 , 0x2E , 0x36 , 0x56 , 0x36 , 0x43 ,
	0x49 , 0x4F , 0x1A , 0x42 , 0x49 , 0x25 , 0x33 , 0x42 ,
	0x28 , 0x2F , 0x4F , 0x4F , 0x42 , 0x4F , 0x6E , 0x00 ,
	0x48 , 0x26 , 0x1E , 0x2A , 0x1E , 0x22 , 0x1A , 0x1A ,
	0x1A , 0x42 , 0x42 , 0x42 , 0x6E , 0x6E , 0x6E , 0x54 ,
	0x54 , 0x54 , 0x1A , 0x1A , 0x1A , 0x42 , 0x42 , 0x42 ,
	0x6D , 0x56 , 0x6D , 0x54 , 0x54 , 0x54 , 0x7F , 0x7F
};

//tab45216
unsigned char freq3data[]=
{
	0x00 , 0x5B , 0x5B , 0x5B , 0x5B , 0x6E , 0x5D , 0x5B ,
	0x58 , 0x59 , 0x57 , 0x58 , 0x52 , 0x59 , 0x5D , 0x3E ,
	0x52 , 0x58 , 0x3E , 0x6E , 0x50 , 0x5D , 0x5A , 0x3C ,
	0x6E , 0x5A , 0x6E , 0x51 , 0x79 , 0x65 , 0x79 , 0x5B ,
	0x63 , 0x6A , 0x51 , 0x79 , 0x5D , 0x52 , 0x5D , 0x67 ,
	0x4C , 0x5D , 0x65 , 0x65 , 0x79 , 0x65 , 0x79 , 0x00 ,
	0x5A , 0x58 , 0x58 , 0x58 , 0x58 , 0x52 , 0x51 , 0x51 ,
	0x51 , 0x79 , 0x79 , 0x79 , 0x70 , 0x6E , 0x6E , 0x5E ,
	0x5E , 0x5E , 0x51 , 0x51 , 0x51 , 0x79 , 0x79 , 0x79 ,
	0x65 , 0x65 , 0x70 , 0x5E , 0x5E , 0x5E , 0x08 , 0x01   
};

unsigned char ampl1data[] = 
{
	0 , 0 , 0 , 0 , 0 ,0xD ,0xD ,0xE ,
	0xF ,0xF ,0xF ,0xF ,0xF ,0xC ,0xD ,0xC ,
	0xF ,0xF ,0xD ,0xD ,0xD ,0xE ,0xD ,0xC ,
	0xD ,0xD ,0xD ,0xC , 9 , 9 , 0 , 0 ,
	0 , 0 , 0 , 0 , 0 , 0 ,0xB ,0xB ,
	0xB ,0xB , 0 , 0 , 1 ,0xB , 0 , 2 ,
	0xE ,0xF ,0xF ,0xF ,0xF ,0xD , 2 , 4 ,
	0 , 2 , 4 , 0 , 1 , 4 , 0 , 1 ,
	4 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
	0 ,0xC , 0 , 0 , 0 , 0 ,0xF ,0xF
};

unsigned char ampl2data[] = 
{
	0 , 0 , 0 , 0 , 0 ,0xA ,0xB ,0xD ,
	0xE ,0xD ,0xC ,0xC ,0xB , 9 ,0xB ,0xB ,
	0xC ,0xC ,0xC , 8 , 8 ,0xC , 8 ,0xA ,
	8 , 8 ,0xA , 3 , 9 , 6 , 0 , 0 ,
	0 , 0 , 0 , 0 , 0 , 0 , 3 , 5 ,
	3 , 4 , 0 , 0 , 0 , 5 ,0xA , 2 ,
	0xE ,0xD ,0xC ,0xD ,0xC , 8 , 0 , 1 ,
	0 , 0 , 1 , 0 , 0 , 1 , 0 , 0 ,
	1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
	0 ,0xA , 0 , 0 ,0xA , 0 , 0 , 0
};

unsigned char ampl3data[] = 
{
	0 , 0 , 0 , 0 , 0 , 8 , 7 , 8 ,
	8 , 1 , 1 , 0 , 1 , 0 , 7 , 5 ,
	1 , 0 , 6 , 1 , 0 , 7 , 0 , 5 ,
	1 , 0 , 8 , 0 , 0 , 3 , 0 , 0 ,
	0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 ,
	0 , 0 , 0 , 0 , 0 , 1 ,0xE , 1 ,
	9 , 1 , 0 , 1 , 0 , 0 , 0 , 0 ,
	0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
	0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
	0 , 7 , 0 , 0 , 5 , 0 , 0x13 , 0x10
};



//tab42240
unsigned char sinus[] = 
{
	0x00 , 0x00 , 0x00 , 0x10 , 0x10 , 0x10 , 0x10 , 0x10 ,
	0x10 , 0x20 , 0x20 , 0x20 , 0x20 , 0x20 , 0x20 , 0x30 ,
	0x30 , 0x30 , 0x30 , 0x30 , 0x30 , 0x30 , 0x40 , 0x40 ,
	0x40 , 0x40 , 0x40 , 0x40 , 0x40 , 0x50 , 0x50 , 0x50 ,
	0x50 , 0x50 , 0x50 , 0x50 , 0x50 , 0x60 , 0x60 , 0x60 , 
	0x60 , 0x60 , 0x60 , 0x60 , 0x60 , 0x60 , 0x60 , 0x60 ,
	0x60 , 0x70 , 0x70 , 0x70 , 0x70 , 0x70 , 0x70 , 0x70 ,
	0x70 , 0x70 , 0x70 , 0x70 , 0x70 , 0x70 , 0x70 , 0x70 ,
	0x70 , 0x70 , 0x70 , 0x70 , 0x70 , 0x70 , 0x70 , 0x70 ,
	0x70 , 0x70 , 0x70 , 0x70 , 0x70 , 0x70 , 0x70 , 0x70 ,
	0x60 , 0x60 , 0x60 , 0x60 , 0x60 , 0x60 , 0x60 , 0x60 ,
	0x60 , 0x60 , 0x60 , 0x60 , 0x50 , 0x50 , 0x50 , 0x50 ,
	0x50 , 0x50 , 0x50 , 0x50 , 0x40 , 0x40 , 0x40 , 0x40 ,
	0x40 , 0x40 , 0x40 , 0x30 , 0x30 , 0x30 , 0x30 , 0x30 ,
	0x30 , 0x30 , 0x20 , 0x20 , 0x20 , 0x20 , 0x20 , 0x20 ,
	0x10 , 0x10 , 0x10 , 0x10 , 0x10 , 0x10 , 0x00 , 0x00 ,
	0x00 , 0x00 , 0x00 , 0xF0 , 0xF0 , 0xF0 , 0xF0 , 0xF0 ,
	0xF0 , 0xE0 , 0xE0 , 0xE0 , 0xE0 , 0xE0 , 0xE0 , 0xD0 ,
	0xD0 , 0xD0 , 0xD0 , 0xD0 , 0xD0 , 0xD0 , 0xC0 , 0xC0 ,
	0xC0 , 0xC0 , 0xC0 , 0xC0 , 0xC0 , 0xB0 , 0xB0 , 0xB0 ,
	0xB0 , 0xB0 , 0xB0 , 0xB0 , 0xB0 , 0xA0 , 0xA0 , 0xA0 ,
	0xA0 , 0xA0 , 0xA0 , 0xA0 , 0xA0 , 0xA0 , 0xA0 , 0xA0 ,
	0xA0 , 0x90 , 0x90 , 0x90 , 0x90 , 0x90 , 0x90 , 0x90 ,
	0x90 , 0x90 , 0x90 , 0x90 , 0x90 , 0x90 , 0x90 , 0x90 ,
	0x90 , 0x90 , 0x90 , 0x90 , 0x90 , 0x90 , 0x90 , 0x90 ,
	0x90 , 0x90 , 0x90 , 0x90 , 0x90 , 0x90 , 0x90 , 0x90 ,
	0xA0 , 0xA0 , 0xA0 , 0xA0 , 0xA0 , 0xA0 , 0xA0 , 0xA0 ,
	0xA0 , 0xA0 , 0xA0 , 0xA0 , 0xB0 , 0xB0 , 0xB0 , 0xB0 ,
	0xB0 , 0xB0 , 0xB0 , 0xB0 , 0xC0 , 0xC0 , 0xC0 , 0xC0 ,
	0xC0 , 0xC0 , 0xC0 , 0xD0 , 0xD0 , 0xD0 , 0xD0 , 0xD0 ,
	0xD0 , 0xD0 , 0xE0 , 0xE0 , 0xE0 , 0xE0 , 0xE0 , 0xE0 ,
	0xF0 , 0xF0 , 0xF0 , 0xF0 , 0xF0 , 0xF0 , 0x00 , 0x00 };

//tab42496
unsigned char rectangle[] = 
{
	0x90 , 0x90 , 0x90 , 0x90 , 0x90 , 0x90 , 0x90 , 0x90 ,
	0x90 , 0x90 , 0x90 , 0x90 , 0x90 , 0x90 , 0x90 , 0x90 ,
	0x90 , 0x90 , 0x90 , 0x90 , 0x90 , 0x90 , 0x90 , 0x90 ,
	0x90 , 0x90 , 0x90 , 0x90 , 0x90 , 0x90 , 0x90 , 0x90 ,
	0x90 , 0x90 , 0x90 , 0x90 , 0x90 , 0x90 , 0x90 , 0x90 ,
	0x90 , 0x90 , 0x90 , 0x90 , 0x90 , 0x90 , 0x90 , 0x90 ,
	0x90 , 0x90 , 0x90 , 0x90 , 0x90 , 0x90 , 0x90 , 0x90 ,
	0x90 , 0x90 , 0x90 , 0x90 , 0x90 , 0x90 , 0x90 , 0x90 ,
	0x90 , 0x90 , 0x90 , 0x90 , 0x90 , 0x90 , 0x90 , 0x90 ,
	0x90 , 0x90 , 0x90 , 0x90 , 0x90 , 0x90 , 0x90 , 0x90 ,
	0x90 , 0x90 , 0x90 , 0x90 , 0x90 , 0x90 , 0x90 , 0x90 ,
	0x90 , 0x90 , 0x90 , 0x90 , 0x90 , 0x90 , 0x90 , 0x90 ,
	0x90 , 0x90 , 0x90 , 0x90 , 0x90 , 0x90 , 0x90 , 0x90 ,
	0x90 , 0x90 , 0x90 , 0x90 , 0x90 , 0x90 , 0x90 , 0x90 ,
	0x90 , 0x90 , 0x90 , 0x90 , 0x90 , 0x90 , 0x90 , 0x90 ,
	0x90 , 0x90 , 0x90 , 0x90 , 0x90 , 0x90 , 0x90 , 0x90 ,
	0x70 , 0x70 , 0x70 , 0x70 , 0x70 , 0x70 , 0x70 , 0x70 ,
	0x70 , 0x70 , 0x70 , 0x70 , 0x70 , 0x70 , 0x70 , 0x70 ,
	0x70 , 0x70 , 0x70 , 0x70 , 0x70 , 0x70 , 0x70 , 0x70 ,
	0x70 , 0x70 , 0x70 , 0x70 , 0x70 , 0x70 , 0x70 , 0x70 ,
	0x70 , 0x70 , 0x70 , 0x70 , 0x70 , 0x70 , 0x70 , 0x70 ,
	0x70 , 0x70 , 0x70 , 0x70 , 0x70 , 0x70 , 0x70 , 0x70 ,
	0x70 , 0x70 , 0x70 , 0x70 , 0x70 , 0x70 , 0x70 , 0x70 ,
	0x70 , 0x70 , 0x70 , 0x70 , 0x70 , 0x70 , 0x70 , 0x70 ,
	0x70 , 0x70 , 0x70 , 0x70 , 0x70 , 0x70 , 0x70 , 0x70 ,
	0x70 , 0x70 , 0x70 , 0x70 , 0x70 , 0x70 , 0x70 , 0x70 ,
	0x70 , 0x70 , 0x70 , 0x70 , 0x70 , 0x70 , 0x70 , 0x70 ,
	0x70 , 0x70 , 0x70 , 0x70 , 0x70 , 0x70 , 0x70 , 0x70 ,
	0x70 , 0x70 , 0x70 , 0x70 , 0x70 , 0x70 , 0x70 , 0x70 ,
	0x70 , 0x70 , 0x70 , 0x70 , 0x70 , 0x70 , 0x70 , 0x70 ,
	0x70 , 0x70 , 0x70 , 0x70 , 0x70 , 0x70 , 0x70 , 0x70 ,
	0x70 , 0x70 , 0x70 , 0x70 , 0x70 , 0x70 , 0x70 , 0x70
};


//tab42752
unsigned char multtable[] = 
{
	0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 ,
	0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 ,
	0x00 , 0x00 , 0x01 , 0x01 , 0x02 , 0x02 , 0x03 , 0x03 ,
	0x04 , 0x04 , 0x05 , 0x05 , 0x06 , 0x06 , 0x07 , 0x07 ,
	0x00 , 0x01 , 0x02 , 0x03 , 0x04 , 0x05 , 0x06 , 0x07 ,
	0x08 , 0x09 , 0x0A , 0x0B , 0x0C , 0x0D , 0x0E , 0x0F ,
	0x00 , 0x01 , 0x03 , 0x04 , 0x06 , 0x07 , 0x09 , 0x0A ,
	0x0C , 0x0D , 0x0F , 0x10 , 0x12 , 0x13 , 0x15 , 0x16 ,
	0x00 , 0x02 , 0x04 , 0x06 , 0x08 , 0x0A , 0x0C , 0x0E ,
	0x10 , 0x12 , 0x14 , 0x16 , 0x18 , 0x1A , 0x1C , 0x1E ,
	0x00 , 0x02 , 0x05 , 0x07 , 0x0A , 0x0C , 0x0F , 0x11 ,
	0x14 , 0x16 , 0x19 , 0x1B , 0x1E , 0x20 , 0x23 , 0x25 ,
	0x00 , 0x03 , 0x06 , 0x09 , 0x0C , 0x0F , 0x12 , 0x15 ,
	0x18 , 0x1B , 0x1E , 0x21 , 0x24 , 0x27 , 0x2A , 0x2D ,
	0x00 , 0x03 , 0x07 , 0x0A , 0x0E , 0x11 , 0x15 , 0x18 ,
	0x1C , 0x1F , 0x23 , 0x26 , 0x2A , 0x2D , 0x31 , 0x34 ,
	0x00 , 0xFC , 0xF8 , 0xF4 , 0xF0 , 0xEC , 0xE8 , 0xE4 ,
	0xE0 , 0xDC , 0xD8 , 0xD4 , 0xD0 , 0xCC , 0xC8 , 0xC4 ,
	0x00 , 0xFC , 0xF9 , 0xF5 , 0xF2 , 0xEE , 0xEB , 0xE7 ,
	0xE4 , 0xE0 , 0xDD , 0xD9 , 0xD6 , 0xD2 , 0xCF , 0xCB ,
	0x00 , 0xFD , 0xFA , 0xF7 , 0xF4 , 0xF1 , 0xEE , 0xEB ,
	0xE8 , 0xE5 , 0xE2 , 0xDF , 0xDC , 0xD9 , 0xD6 , 0xD3 ,
	0x00 , 0xFD , 0xFB , 0xF8 , 0xF6 , 0xF3 , 0xF1 , 0xEE ,
	0xEC , 0xE9 , 0xE7 , 0xE4 , 0xE2 , 0xDF , 0xDD , 0xDA ,
	0x00 , 0xFE , 0xFC , 0xFA , 0xF8 , 0xF6 , 0xF4 , 0xF2 ,
	0xF0 , 0xEE , 0xEC , 0xEA , 0xE8 , 0xE6 , 0xE4 , 0xE2 ,
	0x00 , 0xFE , 0xFD , 0xFB , 0xFA , 0xF8 , 0xF7 , 0xF5 ,
	0xF4 , 0xF2 , 0xF1 , 0xEF , 0xEE , 0xEC , 0xEB , 0xE9 ,
	0x00 , 0xFF , 0xFE , 0xFD , 0xFC , 0xFB , 0xFA , 0xF9 ,
	0xF8 , 0xF7 , 0xF6 , 0xF5 , 0xF4 , 0xF3 , 0xF2 , 0xF1 ,
	0x00 , 0xFF , 0xFF , 0xFE , 0xFE , 0xFD , 0xFD , 0xFC ,
	0xFC , 0xFB , 0xFB , 0xFA , 0xFA , 0xF9 , 0xF9 , 0xF8   
};

//random data ?
unsigned char sampleTable[0x500] =
{
	//00

	0x38 , 0x84 , 0x6B , 0x19 , 0xC6 , 0x63 ,  0x18 , 0x86
	,  0x73 , 0x98 , 0xC6 , 0xB1 , 0x1C , 0xCA , 0x31 , 0x8C
	,  0xC7 , 0x31 , 0x88 , 0xC2 , 0x30 , 0x98 , 0x46 , 0x31
	,  0x18 , 0xC6 , 0x35 ,0xC , 0xCA , 0x31 ,0xC , 0xC6
	//20
	,  0x21 , 0x10 , 0x24 , 0x69 , 0x12 , 0xC2 , 0x31 , 0x14
	,  0xC4 , 0x71 , 8 , 0x4A , 0x22 , 0x49 , 0xAB , 0x6A
	,  0xA8 , 0xAC , 0x49 , 0x51 , 0x32 , 0xD5 , 0x52 , 0x88
	,  0x93 , 0x6C , 0x94 , 0x22 , 0x15 , 0x54 , 0xD2 , 0x25
	//40
	,  0x96 , 0xD4 , 0x50 , 0xA5 , 0x46 , 0x21 , 8 , 0x85
	,  0x6B , 0x18 , 0xC4 , 0x63 , 0x10 , 0xCE , 0x6B , 0x18
	,  0x8C , 0x71 , 0x19 , 0x8C , 0x63 , 0x35 ,0xC , 0xC6
	,  0x33 , 0x99 , 0xCC , 0x6C , 0xB5 , 0x4E , 0xA2 , 0x99
	//60
	,  0x46 , 0x21 , 0x28 , 0x82 , 0x95 , 0x2E , 0xE3 , 0x30
	,  0x9C , 0xC5 , 0x30 , 0x9C , 0xA2 , 0xB1 , 0x9C , 0x67
	,  0x31 , 0x88 , 0x66 , 0x59 , 0x2C , 0x53 , 0x18 , 0x84
	,  0x67 , 0x50 , 0xCA , 0xE3 ,0xA , 0xAC , 0xAB , 0x30
	//80
	,  0xAC , 0x62 , 0x30 , 0x8C , 0x63 , 0x10 , 0x94 , 0x62
	,  0xB1 , 0x8C , 0x82 , 0x28 , 0x96 , 0x33 , 0x98 , 0xD6
	,  0xB5 , 0x4C , 0x62 , 0x29 , 0xA5 , 0x4A , 0xB5 , 0x9C
	,  0xC6 , 0x31 , 0x14 , 0xD6 , 0x38 , 0x9C , 0x4B , 0xB4
	//A0
	,  0x86 , 0x65 , 0x18 , 0xAE , 0x67 , 0x1C , 0xA6 , 0x63
	,  0x19 , 0x96 , 0x23 , 0x19 , 0x84 , 0x13 , 8 , 0xA6
	,  0x52 , 0xAC , 0xCA , 0x22 , 0x89 , 0x6E , 0xAB , 0x19
	,  0x8C , 0x62 , 0x34 , 0xC4 , 0x62 , 0x19 , 0x86 , 0x63
	//C0
	,  0x18 , 0xC4 , 0x23 , 0x58 , 0xD6 , 0xA3 , 0x50 , 0x42
	,  0x54 , 0x4A , 0xAD , 0x4A , 0x25 , 0x11 , 0x6B , 0x64
	,  0x89 , 0x4A , 0x63 , 0x39 , 0x8A , 0x23 , 0x31 , 0x2A
	,  0xEA , 0xA2 , 0xA9 , 0x44 , 0xC5 , 0x12 , 0xCD , 0x42
	//E0
	,  0x34 , 0x8C , 0x62 , 0x18 , 0x8C , 0x63 , 0x11 , 0x48
	,  0x66 , 0x31 , 0x9D , 0x44 , 0x33 , 0x1D , 0x46 , 0x31
	,  0x9C , 0xC6 , 0xB1 ,0xC , 0xCD , 0x32 , 0x88 , 0xC4
	,  0x73 , 0x18 , 0x86 , 0x73 , 8 , 0xD6 , 0x63 , 0x58
	//100
	,	 7 , 0x81 , 0xE0 , 0xF0 , 0x3C , 7 , 0x87 , 0x90
	,  0x3C , 0x7C ,0xF , 0xC7 , 0xC0 , 0xC0 , 0xF0 , 0x7C
	,  0x1E , 7 , 0x80 , 0x80 , 0 , 0x1C , 0x78 , 0x70
	,  0xF1 , 0xC7 , 0x1F , 0xC0 ,0xC , 0xFE , 0x1C , 0x1F
	//120
	,  0x1F ,0xE ,0xA , 0x7A , 0xC0 , 0x71 , 0xF2 , 0x83
	,  0x8F , 3 ,0xF ,0xF ,0xC , 0 , 0x79 , 0xF8
	,  0x61 , 0xE0 , 0x43 ,0xF , 0x83 , 0xE7 , 0x18 , 0xF9
	,  0xC1 , 0x13 , 0xDA , 0xE9 , 0x63 , 0x8F ,0xF , 0x83
	//140
	,  0x83 , 0x87 , 0xC3 , 0x1F , 0x3C , 0x70 , 0xF0 , 0xE1
	,  0xE1 , 0xE3 , 0x87 , 0xB8 , 0x71 ,0xE , 0x20 , 0xE3
	,  0x8D , 0x48 , 0x78 , 0x1C , 0x93 , 0x87 , 0x30 , 0xE1
	,  0xC1 , 0xC1 , 0xE4 , 0x78 , 0x21 , 0x83 , 0x83 , 0xC3
	//160
	,  0x87 , 6 , 0x39 , 0xE5 , 0xC3 , 0x87 , 7 ,0xE
	,  0x1C , 0x1C , 0x70 , 0xF4 , 0x71 , 0x9C , 0x60 , 0x36
	,  0x32 , 0xC3 , 0x1E , 0x3C , 0xF3 , 0x8F ,0xE , 0x3C
	,  0x70 , 0xE3 , 0xC7 , 0x8F ,0xF ,0xF ,0xE , 0x3C
	//180
	,  0x78 , 0xF0 , 0xE3 , 0x87 , 6 , 0xF0 , 0xE3 , 7
	,  0xC1 , 0x99 , 0x87 ,0xF , 0x18 , 0x78 , 0x70 , 0x70
	,  0xFC , 0xF3 , 0x10 , 0xB1 , 0x8C , 0x8C , 0x31 , 0x7C
	,  0x70 , 0xE1 , 0x86 , 0x3C , 0x64 , 0x6C , 0xB0 , 0xE1
	//1A0
	,  0xE3 ,0xF , 0x23 , 0x8F ,0xF , 0x1E , 0x3E , 0x38
	,  0x3C , 0x38 , 0x7B , 0x8F , 7 ,0xE , 0x3C , 0xF4
	,  0x17 , 0x1E , 0x3C , 0x78 , 0xF2 , 0x9E , 0x72 , 0x49
	,  0xE3 , 0x25 , 0x36 , 0x38 , 0x58 , 0x39 , 0xE2 , 0xDE
	//1C0
	,  0x3C , 0x78 , 0x78 , 0xE1 , 0xC7 , 0x61 , 0xE1 , 0xE1
	,  0xB0 , 0xF0 , 0xF0 , 0xC3 , 0xC7 ,0xE , 0x38 , 0xC0
	,  0xF0 , 0xCE , 0x73 , 0x73 , 0x18 , 0x34 , 0xB0 , 0xE1
	,  0xC7 , 0x8E , 0x1C , 0x3C , 0xF8 , 0x38 , 0xF0 , 0xE1
	//1E0
	,  0xC1 , 0x8B , 0x86 , 0x8F , 0x1C , 0x78 , 0x70 , 0xF0
	,  0x78 , 0xAC , 0xB1 , 0x8F , 0x39 , 0x31 , 0xDB , 0x38
	,  0x61 , 0xC3 ,0xE ,0xE , 0x38 , 0x78 , 0x73 , 0x17
	,  0x1E , 0x39 , 0x1E , 0x38 , 0x64 , 0xE1 , 0xF1 , 0xC1
	//200
	,  0x4E ,0xF , 0x40 , 0xA2 , 2 , 0xC5 , 0x8F , 0x81
	,  0xA1 , 0xFC , 0x12 , 8 , 0x64 , 0xE0 , 0x3C , 0x22
	,  0xE0 , 0x45 , 7 , 0x8E ,0xC , 0x32 , 0x90 , 0xF0
	,  0x1F , 0x20 , 0x49 , 0xE0 , 0xF8 ,0xC , 0x60 , 0xF0
	//220
	,  0x17 , 0x1A , 0x41 , 0xAA , 0xA4 , 0xD0 , 0x8D , 0x12
	,  0x82 , 0x1E , 0x1E , 3 , 0xF8 , 0x3E , 3 ,0xC
	,  0x73 , 0x80 , 0x70 , 0x44 , 0x26 , 3 , 0x24 , 0xE1
	,  0x3E , 4 , 0x4E , 4 , 0x1C , 0xC1 , 9 , 0xCC
	//240
	,  0x9E , 0x90 , 0x21 , 7 , 0x90 , 0x43 , 0x64 , 0xC0
	,	0xF , 0xC6 , 0x90 , 0x9C , 0xC1 , 0x5B , 3 , 0xE2
	,  0x1D , 0x81 , 0xE0 , 0x5E , 0x1D , 3 , 0x84 , 0xB8
	,  0x2C ,0xF , 0x80 , 0xB1 , 0x83 , 0xE0 , 0x30 , 0x41
	//260
	,  0x1E , 0x43 , 0x89 , 0x83 , 0x50 , 0xFC , 0x24 , 0x2E
	,  0x13 , 0x83 , 0xF1 , 0x7C , 0x4C , 0x2C , 0xC9 ,0xD
	,  0x83 , 0xB0 , 0xB5 , 0x82 , 0xE4 , 0xE8 , 6 , 0x9C
	,	 7 , 0xA0 , 0x99 , 0x1D , 7 , 0x3E , 0x82 , 0x8F
	//280
	,  0x70 , 0x30 , 0x74 , 0x40 , 0xCA , 0x10 , 0xE4 , 0xE8
	,	0xF , 0x92 , 0x14 , 0x3F , 6 , 0xF8 , 0x84 , 0x88
	,  0x43 , 0x81 ,0xA , 0x34 , 0x39 , 0x41 , 0xC6 , 0xE3
	,  0x1C , 0x47 , 3 , 0xB0 , 0xB8 , 0x13 ,0xA , 0xC2
	//2A0
	,  0x64 , 0xF8 , 0x18 , 0xF9 , 0x60 , 0xB3 , 0xC0 , 0x65
	,  0x20 , 0x60 , 0xA6 , 0x8C , 0xC3 , 0x81 , 0x20 , 0x30
	,  0x26 , 0x1E , 0x1C , 0x38 , 0xD3 , 1 , 0xB0 , 0x26
	,  0x40 , 0xF4 ,0xB , 0xC3 , 0x42 , 0x1F , 0x85 , 0x32
	//2C0
	,  0x26 , 0x60 , 0x40 , 0xC9 , 0xCB , 1 , 0xEC , 0x11
	,  0x28 , 0x40 , 0xFA , 4 , 0x34 , 0xE0 , 0x70 , 0x4C
	,  0x8C , 0x1D , 7 , 0x69 , 3 , 0x16 , 0xC8 , 4
	,  0x23 , 0xE8 , 0xC6 , 0x9A ,0xB , 0x1A , 3 , 0xE0
	//2E0
	,  0x76 , 6 , 5 , 0xCF , 0x1E , 0xBC , 0x58 , 0x31
	,  0x71 , 0x66 , 0 , 0xF8 , 0x3F , 4 , 0xFC ,0xC
	,  0x74 , 0x27 , 0x8A , 0x80 , 0x71 , 0xC2 , 0x3A , 0x26
	,	 6 , 0xC0 , 0x1F , 5 ,0xF , 0x98 , 0x40 , 0xAE
	//300
	,	 1 , 0x7F , 0xC0 , 7 , 0xFF , 0 ,0xE , 0xFE
	,	 0 , 3 , 0xDF , 0x80 , 3 , 0xEF , 0x80 , 0x1B
	,  0xF1 , 0xC2 , 0 , 0xE7 , 0xE0 , 0x18 , 0xFC , 0xE0
	,  0x21 , 0xFC , 0x80 , 0x3C , 0xFC , 0x40 ,0xE , 0x7E
	//320
	,	 0 , 0x3F , 0x3E , 0 ,0xF , 0xFE , 0 , 0x1F
	,  0xFF , 0 , 0x3E , 0xF0 , 7 , 0xFC , 0 , 0x7E
	,  0x10 , 0x3F , 0xFF , 0 , 0x3F , 0x38 ,0xE , 0x7C
	,	 1 , 0x87 ,0xC , 0xFC , 0xC7 , 0 , 0x3E , 4
	//340
	,	0xF , 0x3E , 0x1F ,0xF ,0xF , 0x1F ,0xF , 2
	,  0x83 , 0x87 , 0xCF , 3 , 0x87 ,0xF , 0x3F , 0xC0
	,	 7 , 0x9E , 0x60 , 0x3F , 0xC0 , 3 , 0xFE , 0
	,  0x3F , 0xE0 , 0x77 , 0xE1 , 0xC0 , 0xFE , 0xE0 , 0xC3
	//360
	,  0xE0 , 1 , 0xDF , 0xF8 , 3 , 7 , 0 , 0x7E
	,  0x70 , 0 , 0x7C , 0x38 , 0x18 , 0xFE ,0xC , 0x1E
	,  0x78 , 0x1C , 0x7C , 0x3E ,0xE , 0x1F , 0x1E , 0x1E
	,  0x3E , 0 , 0x7F , 0x83 , 7 , 0xDB , 0x87 , 0x83
	//380
	,	 7 , 0xC7 , 7 , 0x10 , 0x71 , 0xFF , 0 , 0x3F
	,  0xE2 , 1 , 0xE0 , 0xC1 , 0xC3 , 0xE1 , 0 , 0x7F
	,  0xC0 , 5 , 0xF0 , 0x20 , 0xF8 , 0xF0 , 0x70 , 0xFE
	,  0x78 , 0x79 , 0xF8 , 2 , 0x3F ,0xC , 0x8F , 3
	//3a0
	,	0xF , 0x9F , 0xE0 , 0xC1 , 0xC7 , 0x87 , 3 , 0xC3
	,  0xC3 , 0xB0 , 0xE1 , 0xE1 , 0xC1 , 0xE3 , 0xE0 , 0x71
	,  0xF0 , 0 , 0xFC , 0x70 , 0x7C ,0xC , 0x3E , 0x38
	,	0xE , 0x1C , 0x70 , 0xC3 , 0xC7 , 3 , 0x81 , 0xC1
	//3c0
	,  0xC7 , 0xE7 , 0 ,0xF , 0xC7 , 0x87 , 0x19 , 9
	,  0xEF , 0xC4 , 0x33 , 0xE0 , 0xC1 , 0xFC , 0xF8 , 0x70
	,  0xF0 , 0x78 , 0xF8 , 0xF0 , 0x61 , 0xC7 , 0 , 0x1F
	,  0xF8 , 1 , 0x7C , 0xF8 , 0xF0 , 0x78 , 0x70 , 0x3C
	//3e0
	,  0x7C , 0xCE ,0xE , 0x21 , 0x83 , 0xCF , 8 , 7
	,  0x8F , 8 , 0xC1 , 0x87 , 0x8F , 0x80 , 0xC7 , 0xE3
	,	 0 , 7 , 0xF8 , 0xE0 , 0xEF , 0 , 0x39 , 0xF7
	,  0x80 ,0xE , 0xF8 , 0xE1 , 0xE3 , 0xF8 , 0x21 , 0x9F
	//400
	,  0xC0 , 0xFF , 3 , 0xF8 , 7 , 0xC0 , 0x1F , 0xF8
	,  0xC4 , 4 , 0xFC , 0xC4 , 0xC1 , 0xBC , 0x87 , 0xF0
	,	0xF , 0xC0 , 0x7F , 5 , 0xE0 , 0x25 , 0xEC , 0xC0
	,  0x3E , 0x84 , 0x47 , 0xF0 , 0x8E , 3 , 0xF8 , 3
	//420
	,  0xFB , 0xC0 , 0x19 , 0xF8 , 7 , 0x9C ,0xC , 0x17
	,  0xF8 , 7 , 0xE0 , 0x1F , 0xA1 , 0xFC ,0xF , 0xFC
	,	 1 , 0xF0 , 0x3F , 0 , 0xFE , 3 , 0xF0 , 0x1F
	,	 0 , 0xFD , 0 , 0xFF , 0x88 ,0xD , 0xF9 , 1
	//440
	,  0xFF , 0 , 0x70 , 7 , 0xC0 , 0x3E , 0x42 , 0xF3
	,	0xD , 0xC4 , 0x7F , 0x80 , 0xFC , 7 , 0xF0 , 0x5E
	,  0xC0 , 0x3F , 0 , 0x78 , 0x3F , 0x81 , 0xFF , 1
	,  0xF8 , 1 , 0xC3 , 0xE8 ,0xC , 0xE4 , 0x64 , 0x8F
	////460
	,  0xE4 ,0xF , 0xF0 , 7 , 0xF0 , 0xC2 , 0x1F , 0
	,  0x7F , 0xC0 , 0x6F , 0x80 , 0x7E , 3 , 0xF8 , 7
	,  0xF0 , 0x3F , 0xC0 , 0x78 ,0xF , 0x82 , 7 , 0xFE
	,  0x22 , 0x77 , 0x70 , 2 , 0x76 , 3 , 0xFE , 0
	//480
	,  0xFE , 0x67 , 0 , 0x7C , 0xC7 , 0xF1 , 0x8E , 0xC6
	,  0x3B , 0xE0 , 0x3F , 0x84 , 0xF3 , 0x19 , 0xD8 , 3
	,  0x99 , 0xFC , 9 , 0xB8 ,0xF , 0xF8 , 0 , 0x9D
	,  0x24 , 0x61 , 0xF9 ,0xD , 0 , 0xFD , 3 , 0xF0
	//4a0
	,  0x1F , 0x90 , 0x3F , 1 , 0xF8 , 0x1F , 0xD0 ,0xF
	,  0xF8 , 0x37 , 1 , 0xF8 , 7 , 0xF0 ,0xF , 0xC0
	,  0x3F , 0 , 0xFE , 3 , 0xF8 ,0xF , 0xC0 , 0x3F
	,	 0 , 0xFA , 3 , 0xF0 ,0xF , 0x80 , 0xFF , 1
	//4c0
	,  0xB8 , 7 , 0xF0 , 1 , 0xFC , 1 , 0xBC , 0x80
	,  0x13 , 0x1E , 0 , 0x7F , 0xE1 , 0x40 , 0x7F , 0xA0
	,  0x7F , 0xB0 , 0 , 0x3F , 0xC0 , 0x1F , 0xC0 , 0x38
	,	0xF , 0xF0 , 0x1F , 0x80 , 0xFF , 1 , 0xFC , 3
	//4e0
	,  0xF1 , 0x7E , 1 , 0xFE , 1 , 0xF0 , 0xFF , 0 
	,  0x7F , 0xC0 , 0x1D , 7 , 0xF0 ,0xF , 0xC0 , 0x7E 
	,	 6 , 0xE0 , 7 , 0xE0 ,0xF , 0xF8 , 6 , 0xC1 
	,  0xFE , 1 , 0xFC , 3 , 0xE0 ,0xF , 0 , 0xFC
};

// tab40672
unsigned char stressInputTable[] = {
    '*', '1', '2', '3', '4', '5', '6', '7', '8'
};

// tab40682
unsigned char signInputTable1[] = {
    ' ', '.', '?', ',', '-', 'I', 'I', 'E',
    'A', 'A', 'A', 'A', 'U', 'A', 'I', 'E',
    'U', 'O', 'R', 'L', 'W', 'Y', 'W', 'R',
    'L', 'W', 'Y', 'M', 'N', 'N', 'D', 'Q',
    'S', 'S', 'F', 'T', '/', '/', 'Z', 'Z',
    'V', 'D', 'C', '*', 'J', '*', '*', '*',
    'E', 'A', 'O', 'A', 'O', 'U', 'B', '*',
    '*', 'D', '*', '*', 'G', '*', '*', 'G',
    '*', '*', 'P', '*', '*', 'T', '*', '*',
    'K', '*', '*', 'K', '*', '*', 'U', 'U',
    'U'
};

// tab40763
unsigned char signInputTable2[] = {
    '*', '*', '*', '*', '*', 'Y', 'H', 'H',
    'E', 'A', 'H', 'O', 'H', 'X', 'X', 'R',
    'X', 'H', 'X', 'X', 'X', 'X', 'H', '*',
    '*', '*', '*', '*', '*', 'X', 'X', '*',
    '*', 'H', '*', 'H', 'H', 'X', '*', 'H',
    '*', 'H', 'H', '*', '*', '*', '*', '*',
    'Y', 'Y', 'Y', 'W', 'W', 'W', '*', '*',
    '*', '*', '*', '*', '*', '*', '*', 'X',
    '*', '*', '*', '*', '*', '*', '*', '*',
    '*', '*', '*', 'X', '*', '*', 'L', 'M',
    'N'
};

// loc_9F8C
enum {
    FLAG_PLOSIVE = 0x0001,
    FLAG_STOPCONS = 0x0002, /* stop consonant */
    FLAG_VOICED = 0x0004,
    /* 0x08 */
    FLAG_DIPTHONG = 0x0010,
    FLAG_DIP_YX = 0x0020, /* dipthong ending with YX */
    FLAG_CONSONANT = 0x0040,
    FLAG_VOWEL = 0x0080,
    FLAG_PUNCT = 0x0100,
    /* 0x200 */
    FLAG_ALVEOLAR = 0x0400,
    FLAG_NASAL = 0x0800,
    FLAG_LIQUIC = 0x1000, /* liquic consonant */
    FLAG_FRICATIVE = 0x2000
};

unsigned short flags[] = {
    0x8000, 0xC100, 0xC100, 0xC100, 0xC100, 0x00A4, 0x00A4, 0x00A4,
    0x00A4, 0x00A4, 0x00A4, 0x0084, 0x0084, 0x00A4, 0x00A4, 0x0084,
    0x0084, 0x0084, 0x0084, 0x0084, 0x0084, 0x0084, 0x0044, 0x1044,
    0x1044, 0x1044, 0x1044, 0x084C, 0x0C4C, 0x084C, 0x0448, 0x404C,

    0x2440, 0x2040, 0x2040, 0x2440, 0x0040, 0x0040, 0x2444, 0x2044,
    0x2044, 0x2444, 0x2048, 0x2040, 0x004C, 0x2044, 0x0000, 0x0000,
    0x00B4, 0x00B4, 0x00B4, 0x0094, 0x0094, 0x0094, 0x004E, 0x004E,

    0x004E, 0x044E, 0x044E, 0x044E, 0x004E, 0x004E, 0x004E, 0x004E,
    0x004E, 0x004E, 0x004B, 0x004B, 0x004B, 0x044B, 0x044B, 0x044B,
    0x004B, 0x004B, 0x004B, 0x004B, 0x004B, 0x004B, 0x0080, 0x00C1,
    0x00C1
};

// tab45616???
static const unsigned char phonemeStressedLengthTable[] = {
    0x00, 0x12, 0x12, 0x12, 8, 0xB, 9, 0xB,
    0xE, 0xF, 0xB, 0x10, 0xC, 6, 6, 0xE,
    0xC, 0xE, 0xC, 0xB, 8, 8, 0xB, 0xA,
    9, 8, 8, 8, 8, 8, 3, 5,
    2, 2, 2, 2, 2, 2, 6, 6,
    8, 6, 6, 2, 9, 4, 2, 1,
    0xE, 0xF, 0xF, 0xF, 0xE, 0xE, 8, 2,
    2, 7, 2, 1, 7, 2, 2, 7,
    2, 2, 8, 2, 2, 6, 2, 2,
    7, 2, 4, 7, 1, 4, 5, 5
};

// tab45536???
static const unsigned char phonemeLengthTable[] = {
    0, 0x12, 0x12, 0x12, 8, 8, 8, 8,
    8, 0xB, 6, 0xC, 0xA, 5, 5, 0xB,
    0xA, 0xA, 0xA, 9, 8, 7, 9, 7,
    6, 8, 6, 7, 7, 7, 2, 5,
    2, 2, 2, 2, 2, 2, 6, 6,
    7, 6, 6, 2, 8, 3, 1, 0x1E,
    0xD, 0xC, 0xC, 0xC, 0xE, 9, 6, 1,
    2, 5, 1, 1, 6, 1, 2, 6,
    1, 2, 8, 2, 2, 4, 2, 2,
    6, 1, 4, 6, 1, 4, 0xC7, 0xFF
};

/*

Ind  | phoneme |  flags   |
-----|---------|----------|
0    |   *     | 00000000 |
1    |  .*     | 00000000 |
2    |  ?*     | 00000000 |
3    |  ,*     | 00000000 |
4    |  -*     | 00000000 |

VOWELS
5    |  IY     | 10100100 |
6    |  IH     | 10100100 |
7    |  EH     | 10100100 |
8    |  AE     | 10100100 |
9    |  AA     | 10100100 |
10   |  AH     | 10100100 |
11   |  AO     | 10000100 |
17   |  OH     | 10000100 |
12   |  UH     | 10000100 |
16   |  UX     | 10000100 |
15   |  ER     | 10000100 |
13   |  AX     | 10100100 |
14   |  IX     | 10100100 |

DIPTHONGS
48   |  EY     | 10110100 |
49   |  AY     | 10110100 |
50   |  OY     | 10110100 |
51   |  AW     | 10010100 |
52   |  OW     | 10010100 |
53   |  UW     | 10010100 |


21   |  YX     | 10000100 |
20   |  WX     | 10000100 |
18   |  RX     | 10000100 |
19   |  LX     | 10000100 |
37   |  /X     | 01000000 |
30   |  DX     | 01001000 |


22   |  WH     | 01000100 |


VOICED CONSONANTS
23   |  R*     | 01000100 |
24   |  L*     | 01000100 |
25   |  W*     | 01000100 |
26   |  Y*     | 01000100 |
27   |  M*     | 01001100 |
28   |  N*     | 01001100 |
29   |  NX     | 01001100 |
54   |  B*     | 01001110 |
57   |  D*     | 01001110 |
60   |  G*     | 01001110 |
44   |  J*     | 01001100 |
38   |  Z*     | 01000100 |
39   |  ZH     | 01000100 |
40   |  V*     | 01000100 |
41   |  DH     | 01000100 |

unvoiced CONSONANTS
32   |  S*     | 01000000 |
33   |  SH     | 01000000 |
34   |  F*     | 01000000 |
35   |  TH     | 01000000 |
66   |  P*     | 01001011 |
69   |  T*     | 01001011 |
72   |  K*     | 01001011 |
42   |  CH     | 01001000 |
36   |  /H     | 01000000 |

43   |  **     | 01000000 |
45   |  **     | 01000100 |
46   |  **     | 00000000 |
47   |  **     | 00000000 |


55   |  **     | 01001110 |
56   |  **     | 01001110 |
58   |  **     | 01001110 |
59   |  **     | 01001110 |
61   |  **     | 01001110 |
62   |  **     | 01001110 |
63   |  GX     | 01001110 |
64   |  **     | 01001110 |
65   |  **     | 01001110 |
67   |  **     | 01001011 |
68   |  **     | 01001011 |
70   |  **     | 01001011 |
71   |  **     | 01001011 |
73   |  **     | 01001011 |
74   |  **     | 01001011 |
75   |  KX     | 01001011 |
76   |  **     | 01001011 |
77   |  **     | 01001011 |


SPECIAL
78   |  UL     | 10000000 |
79   |  UM     | 11000001 |
80   |  UN     | 11000001 |
31   |  Q*     | 01001100 |

*/

enum {
    pR = 23,
    pD = 57,
    pT = 69,
    BREAK = 254,
    END = 255
};





//some flags
unsigned char tab36376[] = 
{
	0, 0, 0, 0, 0, 0, 0, 0, // 0-7
	0, 0, 0, 0, 0, 0, 0, 0, // 8-15
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 2, 2, 2, 2, 2, 2, 130, // ' ', '!'
	0, 0, 2, 2, 2, 2, 2, 2,
	3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 2, 2, 2, 2, 2, 2,
	2, 192, 168, 176, 172, 192, 160, 184, // '@', 'A'
	160, 192, 188, 160, 172, 168, 172, 192, 
	160, 160, 172, 180, 164, 192, 168, 168,
	176, 192, 188, 0, 0, 0, 2, 0, // 'X', 'Y', 'Z', '[', 
	32, 32, 155, 32, 192, 185, 32, 205,
	163, 76, 138, 142
};

char rules[] =
{
']','A'|0x80,
' ','(','A','.',')',                    '=','E','H','4','Y','.',' '|0x80,
'(','A',')',' ',                        '=','A','H'|0x80,
' ','(','A','R','E',')',' ',            '=','A','A','R'|0x80,
' ','(','A','R',')','O',                '=','A','X','R'|0x80,
'(','A','R',')','#',                    '=','E','H','4','R'|0x80,
' ','^','(','A','S',')','#',            '=','E','Y','4','S'|0x80,
'(','A',')','W','A',                    '=','A','X'|0x80,
'(','A','W',')',                        '=','A','O','5'|0x80,
' ',':','(','A','N','Y',')',            '=','E','H','4','N','I','Y'|0x80,
'(','A',')','^','+','#',                '=','E','Y','5'|0x80,
'#',':','(','A','L','L','Y',')',        '=','U','L','I','Y'|0x80,
' ','(','A','L',')','#',                '=','U','L'|0x80,
'(','A','G','A','I','N',')',            '=','A','X','G','E','H','4','N'|0x80,
'#',':','(','A','G',')','E',            '=','I','H','J'|0x80,
'(','A',')','^','%',                    '=','E','Y'|0x80,
'(','A',')','^','+',':','#',            '=','A','E'|0x80,
' ',':','(','A',')','^','+',' ',        '=','E','Y','4'|0x80,
' ','(','A','R','R',')',                '=','A','X','R'|0x80,
'(','A','R','R',')',                    '=','A','E','4','R'|0x80,
' ','^','(','A','R',')',' ',            '=','A','A','5','R'|0x80,
'(','A','R',')',                        '=','A','A','5','R'|0x80,
'(','A','I','R',')',                    '=','E','H','4','R'|0x80,
'(','A','I',')',                        '=','E','Y','4'|0x80,
'(','A','Y',')',                        '=','E','Y','5'|0x80,
'(','A','U',')',                        '=','A','O','4'|0x80,
'#',':','(','A','L',')',' ',            '=','U','L'|0x80,
'#',':','(','A','L','S',')',' ',        '=','U','L','Z'|0x80,
'(','A','L','K',')',                    '=','A','O','4','K'|0x80,
'(','A','L',')','^',                    '=','A','O','L'|0x80,
' ',':','(','A','B','L','E',')',        '=','E','Y','4','B','U','L'|0x80,
'(','A','B','L','E',')',                '=','A','X','B','U','L'|0x80,
'(','A',')','V','O',                    '=','E','Y','4'|0x80,
'(','A','N','G',')','+',                '=','E','Y','4','N','J'|0x80,
'(','A','T','A','R','I',')',            '=','A','H','T','A','A','4','R','I','Y'|0x80,
'(','A',')','T','O','M',                '=','A','E'|0x80,
'(','A',')','T','T','I',                '=','A','E'|0x80,
' ','(','A','T',')',' ',                '=','A','E','T'|0x80,
' ','(','A',')','T',                    '=','A','H'|0x80,
'(','A',')',                            '=','A','E'|0x80,

']','B'|0x80,
' ','(','B',')',' ',                    '=','B','I','Y','4'|0x80,
' ','(','B','E',')','^','#',            '=','B','I','H'|0x80,
'(','B','E','I','N','G',')',            '=','B','I','Y','4','I','H','N','X'|0x80,
' ','(','B','O','T','H',')',' ',        '=','B','O','W','4','T','H'|0x80,
' ','(','B','U','S',')','#',            '=','B','I','H','4','Z'|0x80,
'(','B','R','E','A','K',')',            '=','B','R','E','Y','5','K'|0x80,
'(','B','U','I','L',')',                '=','B','I','H','4','L'|0x80,
'(','B',')',                            '=','B'|0x80,

']','C'|0x80,
' ','(','C',')',' ',                    '=','S','I','Y','4'|0x80,
' ','(','C','H',')','^',                '=','K'|0x80,
'^','E','(','C','H',')',                '=','K'|0x80,
'(','C','H','A',')','R','#',            '=','K','E','H','5'|0x80,
'(','C','H',')',                        '=','C','H'|0x80,
' ','S','(','C','I',')','#',            '=','S','A','Y','4'|0x80,
'(','C','I',')','A',                    '=','S','H'|0x80,
'(','C','I',')','O',                    '=','S','H'|0x80,
'(','C','I',')','E','N',                '=','S','H'|0x80,
'(','C','I','T','Y',')',                '=','S','I','H','T','I','Y'|0x80,
'(','C',')','+',                        '=','S'|0x80,
'(','C','K',')',                        '=','K'|0x80,
'(','C','O','M','M','O','D','O','R','E',')','=','K','A','A','4','M','A','H','D','O','H','R'|0x80,
'(','C','O','M',')',                    '=','K','A','H','M'|0x80,
'(','C','U','I','T',')',                '=','K','I','H','T'|0x80,
'(','C','R','E','A',')',                '=','K','R','I','Y','E','Y'|0x80,
'(','C',')',                            '=','K'|0x80,

']','D'|0x80,
' ','(','D',')',' ',                    '=','D','I','Y','4'|0x80,
' ','(','D','R','.',')',' ',            '=','D','A','A','4','K','T','E','R'|0x80,
'#',':','(','D','E','D',')',' ',        '=','D','I','H','D'|0x80,
'.','E','(','D',')',' ',                '=','D'|0x80,
'#',':','^','E','(','D',')',' ',        '=','T'|0x80,
' ','(','D','E',')','^','#',            '=','D','I','H'|0x80,
' ','(','D','O',')',' ',                '=','D','U','W'|0x80,
' ','(','D','O','E','S',')',            '=','D','A','H','Z'|0x80,
'(','D','O','N','E',')',' ',            '=','D','A','H','5','N'|0x80,
'(','D','O','I','N','G',')',            '=','D','U','W','4','I','H','N','X'|0x80,
' ','(','D','O','W',')',                '=','D','A','W'|0x80,
'#','(','D','U',')','A',                '=','J','U','W'|0x80,
'#','(','D','U',')','^','#',            '=','J','A','X'|0x80,
'(','D',')',                            '=','D'|0x80,

']','E'|0x80,
' ','(','E',')',' ',                    '=','I','Y','I','Y','4'|0x80,
'#',':','(','E',')',' ','='|0x80,
'\'',':','^','(','E',')',' ','='|0x80,
' ',':','(','E',')',' ',                '=','I','Y'|0x80,
'#','(','E','D',')',' ',                '=','D'|0x80,
'#',':','(','E',')','D',' ','='|0x80,
'(','E','V',')','E','R',                '=','E','H','4','V'|0x80,
'(','E',')','^','%',                    '=','I','Y','4'|0x80,
'(','E','R','I',')','#',                '=','I','Y','4','R','I','Y'|0x80,
'(','E','R','I',')',                    '=','E','H','4','R','I','H'|0x80,
'#',':','(','E','R',')','#',            '=','E','R'|0x80,
'(','E','R','R','O','R',')',            '=','E','H','4','R','O','H','R'|0x80,
'(','E','R','A','S','E',')',            '=','I','H','R','E','Y','5','S'|0x80,
'(','E','R',')','#',                    '=','E','H','R'|0x80,
'(','E','R',')',                        '=','E','R'|0x80,
' ','(','E','V','E','N',')',            '=','I','Y','V','E','H','N'|0x80,
'#',':','(','E',')','W','='|0x80,
'@','(','E','W',')',                    '=','U','W'|0x80,
'(','E','W',')',                        '=','Y','U','W'|0x80,
'(','E',')','O',                        '=','I','Y'|0x80,
'#',':','&','(','E','S',')',' ',        '=','I','H','Z'|0x80,
'#',':','(','E',')','S',' ','='|0x80,
'#',':','(','E','L','Y',')',' ',        '=','L','I','Y'|0x80,
'#',':','(','E','M','E','N','T',')',    '=','M','E','H','N','T'|0x80,
'(','E','F','U','L',')',                '=','F','U','H','L'|0x80,
'(','E','E',')',                        '=','I','Y','4'|0x80,
'(','E','A','R','N',')',                '=','E','R','5','N'|0x80,
' ','(','E','A','R',')','^',            '=','E','R','5'|0x80,
'(','E','A','D',')',                    '=','E','H','D'|0x80,
'#',':','(','E','A',')',' ',            '=','I','Y','A','X'|0x80,
'(','E','A',')','S','U',                '=','E','H','5'|0x80,
'(','E','A',')',                        '=','I','Y','5'|0x80,
'(','E','I','G','H',')',                '=','E','Y','4'|0x80,
'(','E','I',')',                        '=','I','Y','4'|0x80,
' ','(','E','Y','E',')',                '=','A','Y','4'|0x80,
'(','E','Y',')',                        '=','I','Y'|0x80,
'(','E','U',')',                        '=','Y','U','W','5'|0x80,
'(','E','Q','U','A','L',')',            '=','I','Y','4','K','W','U','L'|0x80,
'(','E',')',                            '=','E','H'|0x80,

']','F'|0x80,
' ','(','F',')',' ',                    '=','E','H','4','F'|0x80,
'(','F','U','L',')',                    '=','F','U','H','L'|0x80,
'(','F','R','I','E','N','D',')',        '=','F','R','E','H','5','N','D'|0x80,
'(','F','A','T','H','E','R',')',        '=','F','A','A','4','D','H','E','R'|0x80,
'(','F',')','F','='|0x80,
'(','F',')',                            '=','F'|0x80,

']','G'|0x80,
' ','(','G',')',' ',                    '=','J','I','Y','4'|0x80,
'(','G','I','V',')',                    '=','G','I','H','5','V'|0x80,
' ','(','G',')','I','^',                '=','G'|0x80,
'(','G','E',')','T',                    '=','G','E','H','5'|0x80,
'S','U','(','G','G','E','S',')',        '=','G','J','E','H','4','S'|0x80,
'(','G','G',')',                        '=','G'|0x80,
' ','B','#','(','G',')',                '=','G'|0x80,
'(','G',')','+',                        '=','J'|0x80,
'(','G','R','E','A','T',')',            '=','G','R','E','Y','4','T'|0x80,
'(','G','O','N',')','E',                '=','G','A','O','5','N'|0x80,
'#','(','G','H',')','='|0x80,
' ','(','G','N',')',                    '=','N'|0x80,
'(','G',')',                            '=','G'|0x80,

']','H'|0x80,
' ','(','H',')',' ',                    '=','E','Y','4','C','H'|0x80,
' ','(','H','A','V',')',                '=','/','H','A','E','6','V'|0x80,
' ','(','H','E','R','E',')',            '=','/','H','I','Y','R'|0x80,
' ','(','H','O','U','R',')',            '=','A','W','5','E','R'|0x80,
'(','H','O','W',')',                    '=','/','H','A','W'|0x80,
'(','H',')','#',                        '=','/','H'|0x80,
'(','H',')','='|0x80,

']','I'|0x80,
' ','(','I','N',')',                    '=','I','H','N'|0x80,
' ','(','I',')',' ',                    '=','A','Y','4'|0x80,
'(','I',')',' ',                        '=','A','Y'|0x80,
'(','I','N',')','D',                    '=','A','Y','5','N'|0x80,
'S','E','M','(','I',')',                '=','I','Y'|0x80,
' ','A','N','T','(','I',')',            '=','A','Y'|0x80,
'(','I','E','R',')',                    '=','I','Y','E','R'|0x80,
'#',':','R','(','I','E','D',')',' ',    '=','I','Y','D'|0x80,
'(','I','E','D',')',' ',                '=','A','Y','5','D'|0x80,
'(','I','E','N',')',                    '=','I','Y','E','H','N'|0x80,
'(','I','E',')','T',                    '=','A','Y','4','E','H'|0x80,
'(','I','\'',')',                        '=','A','Y','5'|0x80,
' ',':','(','I',')','^','%',            '=','A','Y','5'|0x80,
' ',':','(','I','E',')',' ',            '=','A','Y','4'|0x80,
'(','I',')','%',                        '=','I','Y'|0x80,
'(','I','E',')',                        '=','I','Y','4'|0x80,
' ','(','I','D','E','A',')',            '=','A','Y','D','I','Y','5','A','H'|0x80,
'(','I',')','^','+',':','#',            '=','I','H'|0x80,
'(','I','R',')','#',                    '=','A','Y','R'|0x80,
'(','I','Z',')','%',                    '=','A','Y','Z'|0x80,
'(','I','S',')','%',                    '=','A','Y','Z'|0x80,
'I','^','(','I',')','^','#',            '=','I','H'|0x80,
'+','^','(','I',')','^','+',            '=','A','Y'|0x80,
'#',':','^','(','I',')','^','+',        '=','I','H'|0x80,
'(','I',')','^','+',                    '=','A','Y'|0x80,
'(','I','R',')',                        '=','E','R'|0x80,
'(','I','G','H',')',                    '=','A','Y','4'|0x80,
'(','I','L','D',')',                    '=','A','Y','5','L','D'|0x80,
' ','(','I','G','N',')',                '=','I','H','G','N'|0x80,
'(','I','G','N',')',' ',                '=','A','Y','4','N'|0x80,
'(','I','G','N',')','^',                '=','A','Y','4','N'|0x80,
'(','I','G','N',')','%',                '=','A','Y','4','N'|0x80,
'(','I','C','R','O',')',                '=','A','Y','4','K','R','O','H'|0x80,
'(','I','Q','U','E',')',                '=','I','Y','4','K'|0x80,
'(','I',')',                            '=','I','H'|0x80,

']','J'|0x80,
' ','(','J',')',' ',                    '=','J','E','Y','4'|0x80,
'(','J',')',                            '=','J'|0x80,

']','K'|0x80,
' ','(','K',')',' ',                    '=','K','E','Y','4'|0x80,
' ','(','K',')','N','='|0x80,
'(','K',')',                            '=','K'|0x80,

']','L'|0x80,
' ','(','L',')',' ',                    '=','E','H','4','L'|0x80,
'(','L','O',')','C','#',                '=','L','O','W'|0x80,
'L','(','L',')','='|0x80,
'#',':','^','(','L',')','%',            '=','U','L'|0x80,
'(','L','E','A','D',')',                '=','L','I','Y','D'|0x80,
' ','(','L','A','U','G','H',')',        '=','L','A','E','4','F'|0x80,
'(','L',')',                            '=','L'|0x80,

']','M'|0x80,
' ','(','M',')',' ',                    '=','E','H','4','M'|0x80,
' ','(','M','R','.',')',' ',            '=','M','I','H','4','S','T','E','R'|0x80,
' ','(','M','S','.',')',                '=','M','I','H','5','Z'|0x80,
' ','(','M','R','S','.',')',' ',        '=','M','I','H','4','S','I','X','Z'|0x80,
'(','M','O','V',')',                    '=','M','U','W','4','V'|0x80,
'(','M','A','C','H','I','N',')',        '=','M','A','H','S','H','I','Y','5','N'|0x80,
'M','(','M',')','='|0x80,
'(','M',')',                            '=','M'|0x80,

']','N'|0x80,
' ','(','N',')',' ',                    '=','E','H','4','N'|0x80,
'E','(','N','G',')','+',                '=','N','J'|0x80,
'(','N','G',')','R',                    '=','N','X','G'|0x80,
'(','N','G',')','#',                    '=','N','X','G'|0x80,
'(','N','G','L',')','%',                '=','N','X','G','U','L'|0x80,
'(','N','G',')',                        '=','N','X'|0x80,
'(','N','K',')',                        '=','N','X','K'|0x80,
' ','(','N','O','W',')',' ',            '=','N','A','W','4'|0x80,
'N','(','N',')','='|0x80,
'(','N','O','N',')','E',                '=','N','A','H','4','N'|0x80,
'(','N',')',                            '=','N'|0x80,

']','O'|0x80,
' ','(','O',')',' ',                    '=','O','H','4','W'|0x80,
'(','O','F',')',' ',                    '=','A','H','V'|0x80,
' ','(','O','H',')',' ',                '=','O','W','5'|0x80,
'(','O','R','O','U','G','H',')',        '=','E','R','4','O','W'|0x80,
'#',':','(','O','R',')',' ',            '=','E','R'|0x80,
'#',':','(','O','R','S',')',' ',        '=','E','R','Z'|0x80,
'(','O','R',')',                        '=','A','O','R'|0x80,
' ','(','O','N','E',')',                '=','W','A','H','N'|0x80,
'#','(','O','N','E',')',' ',            '=','W','A','H','N'|0x80,
'(','O','W',')',                        '=','O','W'|0x80,
' ','(','O','V','E','R',')',            '=','O','W','5','V','E','R'|0x80,
'P','R','(','O',')','V',                '=','U','W','4'|0x80,
'(','O','V',')',                        '=','A','H','4','V'|0x80,
'(','O',')','^','%',                    '=','O','W','5'|0x80,
'(','O',')','^','E','N',                '=','O','W'|0x80,
'(','O',')','^','I','#',                '=','O','W','5'|0x80,
'(','O','L',')','D',                    '=','O','W','4','L'|0x80,
'(','O','U','G','H','T',')',            '=','A','O','5','T'|0x80,
'(','O','U','G','H',')',                '=','A','H','5','F'|0x80,
' ','(','O','U',')',                    '=','A','W'|0x80,
'H','(','O','U',')','S','#',            '=','A','W','4'|0x80,
'(','O','U','S',')',                    '=','A','X','S'|0x80,
'(','O','U','R',')',                    '=','O','H','R'|0x80,
'(','O','U','L','D',')',                '=','U','H','5','D'|0x80,
'(','O','U',')','^','L',                '=','A','H','5'|0x80,
'(','O','U','P',')',                    '=','U','W','5','P'|0x80,
'(','O','U',')',                        '=','A','W'|0x80,
'(','O','Y',')',                        '=','O','Y'|0x80,
'(','O','I','N','G',')',                '=','O','W','4','I','H','N','X'|0x80,
'(','O','I',')',                        '=','O','Y','5'|0x80,
'(','O','O','R',')',                    '=','O','H','5','R'|0x80,
'(','O','O','K',')',                    '=','U','H','5','K'|0x80,
'F','(','O','O','D',')',                '=','U','W','5','D'|0x80,
'L','(','O','O','D',')',                '=','A','H','5','D'|0x80,
'M','(','O','O','D',')',                '=','U','W','5','D'|0x80,
'(','O','O','D',')',                    '=','U','H','5','D'|0x80,
'F','(','O','O','T',')',                '=','U','H','5','T'|0x80,
'(','O','O',')',                        '=','U','W','5'|0x80,
'(','O','\'',')',                        '=','O','H'|0x80,
'(','O',')','E',                        '=','O','W'|0x80,
'(','O',')',' ',                        '=','O','W'|0x80,
'(','O','A',')',                        '=','O','W','4'|0x80,
' ','(','O','N','L','Y',')',            '=','O','W','4','N','L','I','Y'|0x80,
' ','(','O','N','C','E',')',            '=','W','A','H','4','N','S'|0x80,
'(','O','N','\'','T',')',                '=','O','W','4','N','T'|0x80,
'C','(','O',')','N',                    '=','A','A'|0x80,
'(','O',')','N','G',                    '=','A','O'|0x80,
' ',':','^','(','O',')','N',            '=','A','H'|0x80,
'I','(','O','N',')',                    '=','U','N'|0x80,
'#',':','(','O','N',')',                '=','U','N'|0x80,
'#','^','(','O','N',')',                '=','U','N'|0x80,
'(','O',')','S','T',                    '=','O','W'|0x80,
'(','O','F',')','^',                    '=','A','O','4','F'|0x80,
'(','O','T','H','E','R',')',            '=','A','H','5','D','H','E','R'|0x80,
'R','(','O',')','B',                    '=','R','A','A'|0x80,
'^','R','(','O',')',':','#',            '=','O','W','5'|0x80,
'(','O','S','S',')',' ',                '=','A','O','5','S'|0x80,
'#',':','^','(','O','M',')',            '=','A','H','M'|0x80,
'(','O',')',                            '=','A','A'|0x80,

']','P'|0x80,
' ','(','P',')',' ',                    '=','P','I','Y','4'|0x80,
'(','P','H',')',                        '=','F'|0x80,
'(','P','E','O','P','L',')',            '=','P','I','Y','5','P','U','L'|0x80,
'(','P','O','W',')',                    '=','P','A','W','4'|0x80,
'(','P','U','T',')',' ',                '=','P','U','H','T'|0x80,
'(','P',')','P','='|0x80,
'(','P',')','S','='|0x80,
'(','P',')','N','='|0x80,
'(','P','R','O','F','.',')',            '=','P','R','O','H','F','E','H','4','S','E','R'|0x80,
'(','P',')',                            '=','P'|0x80,

']','Q'|0x80,
' ','(','Q',')',' ',                    '=','K','Y','U','W','4'|0x80,
'(','Q','U','A','R',')',                '=','K','W','O','H','5','R'|0x80,
'(','Q','U',')',                        '=','K','W'|0x80,
'(','Q',')',                            '=','K'|0x80,
']','R'|0x80,
' ','(','R',')',' ',                    '=','A','A','5','R'|0x80,
' ','(','R','E',')','^','#',            '=','R','I','Y'|0x80,
'(','R',')','R','='|0x80,
'(','R',')',                            '=','R'|0x80,

']','S'|0x80,
' ','(','S',')',' ',                    '=','E','H','4','S'|0x80,
'(','S','H',')',                        '=','S','H'|0x80,
'#','(','S','I','O','N',')',            '=','Z','H','U','N'|0x80,
'(','S','O','M','E',')',                '=','S','A','H','M'|0x80,
'#','(','S','U','R',')','#',            '=','Z','H','E','R'|0x80,
'(','S','U','R',')','#',                '=','S','H','E','R'|0x80,
'#','(','S','U',')','#',                '=','Z','H','U','W'|0x80,
'#','(','S','S','U',')','#',            '=','S','H','U','W'|0x80,
'#','(','S','E','D',')',                '=','Z','D'|0x80,
'#','(','S',')','#',                    '=','Z'|0x80,
'(','S','A','I','D',')',                '=','S','E','H','D'|0x80,
'^','(','S','I','O','N',')',            '=','S','H','U','N'|0x80,
'(','S',')','S','='|0x80,
'.','(','S',')',' ',                    '=','Z'|0x80,
'#',':','.','E','(','S',')',' ',        '=','Z'|0x80,
'#',':','^','#','(','S',')',' ',        '=','S'|0x80,
'U','(','S',')',' ',                    '=','S'|0x80,
' ',':','#','(','S',')',' ',            '=','Z'|0x80,
'#','#','(','S',')',' ',                '=','Z'|0x80,
' ','(','S','C','H',')',                '=','S','K'|0x80,
'(','S',')','C','+','='|0x80,
'#','(','S','M',')',                    '=','Z','U','M'|0x80,
'#','(','S','N',')','\'',                '=','Z','U','M'|0x80,
'(','S','T','L','E',')',                '=','S','U','L'|0x80,
'(','S',')',                            '=','S'|0x80,

']','T'|0x80,
' ','(','T',')',' ',                    '=','T','I','Y','4'|0x80,
' ','(','T','H','E',')',' ','#',        '=','D','H','I','Y'|0x80,
' ','(','T','H','E',')',' ',            '=','D','H','A','X'|0x80,
'(','T','O',')',' ',                    '=','T','U','X'|0x80,
' ','(','T','H','A','T',')',            '=','D','H','A','E','T'|0x80,
' ','(','T','H','I','S',')',' ',        '=','D','H','I','H','S'|0x80,
' ','(','T','H','E','Y',')',            '=','D','H','E','Y'|0x80,
' ','(','T','H','E','R','E',')',        '=','D','H','E','H','R'|0x80,
'(','T','H','E','R',')',                '=','D','H','E','R'|0x80,
'(','T','H','E','I','R',')',            '=','D','H','E','H','R'|0x80,
' ','(','T','H','A','N',')',' ',        '=','D','H','A','E','N'|0x80,
' ','(','T','H','E','M',')',' ',        '=','D','H','A','E','N'|0x80,
'(','T','H','E','S','E',')',' ',        '=','D','H','I','Y','Z'|0x80,
' ','(','T','H','E','N',')',            '=','D','H','E','H','N'|0x80,
'(','T','H','R','O','U','G','H',')',    '=','T','H','R','U','W','4'|0x80,
'(','T','H','O','S','E',')',            '=','D','H','O','H','Z'|0x80,
'(','T','H','O','U','G','H',')',' ',    '=','D','H','O','W'|0x80,
'(','T','O','D','A','Y',')',            '=','T','U','X','D','E','Y'|0x80,
'(','T','O','M','O',')','R','R','O','W','=','T','U','M','A','A','5'|0x80,
'(','T','O',')','T','A','L',            '=','T','O','W','5'|0x80,
' ','(','T','H','U','S',')',            '=','D','H','A','H','4','S'|0x80,
'(','T','H',')',                        '=','T','H'|0x80,
'#',':','(','T','E','D',')',            '=','T','I','X','D'|0x80,
'S','(','T','I',')','#','N',            '=','C','H'|0x80,
'(','T','I',')','O',                    '=','S','H'|0x80,
'(','T','I',')','A',                    '=','S','H'|0x80,
'(','T','I','E','N',')',                '=','S','H','U','N'|0x80,
'(','T','U','R',')','#',                '=','C','H','E','R'|0x80,
'(','T','U',')','A',                    '=','C','H','U','W'|0x80,
' ','(','T','W','O',')',                '=','T','U','W'|0x80,
'&','(','T',')','E','N',' ','='|0x80,
'(','T',')',                            '=','T'|0x80,

']','U'|0x80,
' ','(','U',')',' ',                    '=','Y','U','W','4'|0x80,
' ','(','U','N',')','I',                '=','Y','U','W','N'|0x80,
' ','(','U','N',')',                    '=','A','H','N'|0x80,
' ','(','U','P','O','N',')',            '=','A','X','P','A','O','N'|0x80,
'@','(','U','R',')','#',                '=','U','H','4','R'|0x80,
'(','U','R',')','#',                    '=','Y','U','H','4','R'|0x80,
'(','U','R',')',                        '=','E','R'|0x80,
'(','U',')','^',' ',                    '=','A','H'|0x80,
'(','U',')','^','^',                    '=','A','H','5'|0x80,
'(','U','Y',')',                        '=','A','Y','5'|0x80,
' ','G','(','U',')','#','='|0x80,
'G','(','U',')','%','='|0x80,
'G','(','U',')','#',                    '=','W'|0x80,
'#','N','(','U',')',                    '=','Y','U','W'|0x80,
'@','(','U',')',                        '=','U','W'|0x80,
'(','U',')',                            '=','Y','U','W'|0x80,

']','V'|0x80,
' ','(','V',')',' ',                    '=','V','I','Y','4'|0x80,
'(','V','I','E','W',')',                '=','V','Y','U','W','5'|0x80,
'(','V',')',                            '=','V'|0x80,

']','W'|0x80,
' ','(','W',')',' ',                    '=','D','A','H','4','B','U','L','Y','U','W'|0x80,
' ','(','W','E','R','E',')',            '=','W','E','R'|0x80,
'(','W','A',')','S','H',                '=','W','A','A'|0x80,
'(','W','A',')','S','T',                '=','W','E','Y'|0x80,
'(','W','A',')','S',                    '=','W','A','H'|0x80,
'(','W','A',')','T',                    '=','W','A','A'|0x80,
'(','W','H','E','R','E',')',            '=','W','H','E','H','R'|0x80,
'(','W','H','A','T',')',                '=','W','H','A','H','T'|0x80,
'(','W','H','O','L',')',                '=','/','H','O','W','L'|0x80,
'(','W','H','O',')',                    '=','/','H','U','W'|0x80,
'(','W','H',')',                        '=','W','H'|0x80,
'(','W','A','R',')','#',                '=','W','E','H','R'|0x80,
'(','W','A','R',')',                    '=','W','A','O','R'|0x80,
'(','W','O','R',')','^',                '=','W','E','R'|0x80,
'(','W','R',')',                        '=','R'|0x80,
'(','W','O','M',')','A',                '=','W','U','H','M'|0x80,
'(','W','O','M',')','E',                '=','W','I','H','M'|0x80,
'(','W','E','A',')','R',                '=','W','E','H'|0x80,
'(','W','A','N','T',')',                '=','W','A','A','5','N','T'|0x80,
'A','N','S','(','W','E','R',')',        '=','E','R'|0x80,
'(','W',')',                            '=','W'|0x80,

']','X'|0x80,
' ','(','X',')',' ',                    '=','E','H','4','K','R'|0x80,
' ','(','X',')',                        '=','Z'|0x80,
'(','X',')',                            '=','K','S'|0x80,

']','Y'|0x80,
' ','(','Y',')',' ',                    '=','W','A','Y','4'|0x80,
'(','Y','O','U','N','G',')',            '=','Y','A','H','N','X'|0x80,
' ','(','Y','O','U','R',')',            '=','Y','O','H','R'|0x80,
' ','(','Y','O','U',')',                '=','Y','U','W'|0x80,
' ','(','Y','E','S',')',                '=','Y','E','H','S'|0x80,
' ','(','Y',')',                        '=','Y'|0x80,
'F','(','Y',')',                        '=','A','Y'|0x80,
'P','S','(','Y','C','H',')',            '=','A','Y','K'|0x80,
'#',':','^','(','Y',')',                '=','I','Y'|0x80,
'#',':','^','(','Y',')','I',            '=','I','Y'|0x80,
' ',':','(','Y',')',' ',                '=','A','Y'|0x80,
' ',':','(','Y',')','#',                '=','A','Y'|0x80,
' ',':','(','Y',')','^','+',':','#',    '=','I','H'|0x80,
' ',':','(','Y',')','^','#',            '=','A','Y'|0x80,
'(','Y',')',                            '=','I','H'|0x80,

']','Z'|0x80,
' ','(','Z',')',' ',                    '=','Z','I','Y','4'|0x80,
'(','Z',')',                            '=','Z'|0x80,
'j'|0x80
};

char rules2[] =
{
'(','A',')',                            '='|0x80,
'(','!',')',                            '=','.'|0x80,
'(','"',')',' ',                        '=','-','A','H','5','N','K','W','O','W','T','-'|0x80,
'(','"',')',                            '=','K','W','O','W','4','T','-'|0x80,
'(','#',')',                            '=',' ','N','A','H','4','M','B','E','R'|0x80,
'(','$',')',                            '=',' ','D','A','A','4','L','E','R'|0x80,
'(','%',')',                            '=',' ','P','E','R','S','E','H','4','N','T'|0x80,
'(','&',')',                            '=',' ','A','E','N','D'|0x80,
'(','\'',')',                           '='|0x80,
'(','*',')',                            '=',' ','A','E','4','S','T','E','R','I','H','S','K'|0x80,
'(','+',')',                            '=',' ','P','L','A','H','4','S'|0x80,
'(',',',')',                            '=',','|0x80,
' ','(','-',')',' ',                    '=','-'|0x80,
'(','-',')',                            '='|0x80,
'(','.',')',                            '=',' ','P','O','Y','N','T'|0x80,
'(','/',')',                            '=',' ','S','L','A','E','4','S','H'|0x80,
'(','0',')',                            '=',' ','Z','I','Y','4','R','O','W'|0x80,
' ','(','1','S','T',')',                '=','F','E','R','4','S','T'|0x80,
' ','(','1','0','T','H',')',            '=','T','E','H','4','N','T','H'|0x80,
'(','1',')',                            '=',' ','W','A','H','4','N'|0x80,
' ','(','2','N','D',')',                '=','S','E','H','4','K','U','N','D'|0x80,
'(','2',')',                            '=',' ','T','U','W','4'|0x80,
' ','(','3','R','D',')',                '=','T','H','E','R','4','D'|0x80,
'(','3',')',                            '=',' ','T','H','R','I','Y','4'|0x80,
'(','4',')',                            '=',' ','F','O','H','4','R'|0x80,
' ','(','5','T','H',')',                '=','F','I','H','4','F','T','H'|0x80,
'(','5',')',                            '=',' ','F','A','Y','4','V'|0x80,
' ','(','6','4',')',' ',                '=','S','I','H','4','K','S','T','I','Y',' ','F','O','H','R'|0x80,
'(','6',')',                            '=',' ','S','I','H','4','K','S'|0x80,
'(','7',')',                            '=',' ','S','E','H','4','V','U','N'|0x80,
' ','(','8','T','H',')',                '=','E','Y','4','T','H'|0x80,
'(','8',')',                            '=',' ','E','Y','4','T'|0x80,
'(','9',')',                            '=',' ','N','A','Y','4','N'|0x80,
'(',':',')',                            '=','.'|0x80,
'(',';',')',                            '=','.'|0x80,
'(','<',')',                            '=',' ','L','E','H','4','S',' ','D','H','A','E','N'|0x80,
'(','=',')',                            '=',' ','I','Y','4','K','W','U','L','Z'|0x80,
'(','>',')',                            '=',' ','G','R','E','Y','4','T','E','R',' ','D','H','A','E','N'|0x80,
'(','?',')',                            '=','?'|0x80,
'(','@',')',                            '=',' ','A','E','6','T'|0x80,
'(','^',')',                            '=',' ','K','A','E','4','R','I','X','T'|0x80,
']','A'|0x80
};


//26 items. From 'A' to 'Z'
// positions for mem62 and mem63 for each character
unsigned char tab37489[] =
{
0, 149, 247, 162, 57, 197, 6, 126,
199, 38, 55, 78, 145, 241, 85, 161,
254, 36, 69, 45, 167, 54, 83, 46,
71, 218
};

unsigned char tab37515[] =
{
125, 126, 126, 127, 128, 129, 130, 130,
130, 132, 132, 132, 132, 132, 133, 135,
135, 136, 136, 137, 138, 139, 139, 140,
140, 140
};

void SetSAMInputFull(unsigned char* _input, unsigned char _speed, unsigned char _pitch, unsigned char _mouth, unsigned char _throat)
{
    speed = _speed;
    pitch = _pitch;
    mouth = _mouth;
    throat = _throat;

    int i, l;
    l = strlen((char*)_input);
    if (l > 254) l = 254;
    for (i = 0; i < l; i++)
        input[i] = _input[i];
    input[l] = 0;
}


char* GetBuffer() { return buffer; };

int GetBufferLength()
{
    return bufferpos / 50;
}


void Init()
{
    int i;
    SetMouthThroat(mouth, throat);

    bufferpos = 0;
    // TODO, check for free the memory, 10 seconds of output should be more than enough
    buffer = malloc(22050 * 10);

    for (i = 0; i < 256; i++) {
        stress[i] = 0;
        phonemeLength[i] = 0;
    }

    for (i = 0; i < 60; i++) {
        phonemeIndexOutput[i] = 0;
        stressOutput[i] = 0;
        phonemeLengthOutput[i] = 0;
    }
    phonemeindex[255] = END; // to prevent buffer overflow // ML : changed from 32 to 255 to stop freezing with long inputs
}

int SAMMain()
{
    unsigned char X = 0; //!! is this intended like this?
    Init();
    /* FIXME: At odds with assignment in Init() */
    phonemeindex[255] = 32; // to prevent buffer overflow

    if (!Parser1()) return 0;
    Parser2();
    CopyStress();
    SetPhonemeLength();
    AdjustLengths();
    Code41240();
    do {
        if (phonemeindex[X] > 80) {
            phonemeindex[X] = END;
            break; // error: delete all behind it
        }
    } while (++X != 0);
    InsertBreath();

    PrepareOutput();
    return 1;
}

void PrepareOutput()
{
    unsigned char srcpos = 0; // Position in source
    unsigned char destpos = 0; // Position in output

    while (1) {
        unsigned char A = phonemeindex[srcpos];
        phonemeIndexOutput[destpos] = A;
        switch (A) {
            case END:
                Render();
                return;
            case BREAK:
                phonemeIndexOutput[destpos] = END;
                Render();
                destpos = 0;
                break;
            case 0:
                break;
            default:
                phonemeLengthOutput[destpos] = phonemeLength[srcpos];
                stressOutput[destpos] = stress[srcpos];
                ++destpos;
                break;
        }
        ++srcpos;
    }
}

void InsertBreath()
{
    unsigned char mem54 = 255;
    unsigned char len = 0;
    unsigned char index; // variable Y

    unsigned char pos = 0;

    while ((index = phonemeindex[pos]) != END) {
        len += phonemeLength[pos];
        if (len < 232) {
            if (index == BREAK) {
            } else if (!(flags[index] & FLAG_PUNCT)) {
                if (index == 0) mem54 = pos;
            } else {
                len = 0;
                Insert(++pos, BREAK, 0, 0);
            }
        } else {
            pos = mem54;
            phonemeindex[pos] = 31; // 'Q*' glottal stop
            phonemeLength[pos] = 4;
            stress[pos] = 0;

            len = 0;
            Insert(++pos, BREAK, 0, 0);
        }
        ++pos;
    }
}

// Iterates through the phoneme buffer, copying the stress value from
// the following phoneme under the following circumstance:

//     1. The current phoneme is voiced, excluding plosives and fricatives
//     2. The following phoneme is voiced, excluding plosives and fricatives, and
//     3. The following phoneme is stressed
//
//  In those cases, the stress value+1 from the following phoneme is copied.
//
// For example, the word LOITER is represented as LOY5TER, with as stress
// of 5 on the dipthong OY. This routine will copy the stress value of 6 (5+1)
// to the L that precedes it.

void CopyStress()
{
    // loop thought all the phonemes to be output
    unsigned char pos = 0; // mem66
    unsigned char Y;
    while ((Y = phonemeindex[pos]) != END) {
        // if CONSONANT_FLAG set, skip - only vowels get stress
        if (flags[Y] & 64) {
            Y = phonemeindex[pos + 1];

            // if the following phoneme is the end, or a vowel, skip
            if (Y != END && (flags[Y] & 128) != 0) {
                // get the stress value at the next position
                Y = stress[pos + 1];
                if (Y && !(Y & 128)) {
                    // if next phoneme is stressed, and a VOWEL OR ER
                    // copy stress from next phoneme to this one
                    stress[pos] = Y + 1;
                }
            }
        }

        ++pos;
    }
}

void Insert(unsigned char position /*var57*/, unsigned char mem60, unsigned char mem59, unsigned char mem58)
{
    int i;
    for (i = 253; i >= position; i--) // ML : always keep last safe-guarding 255
    {
        phonemeindex[i + 1] = phonemeindex[i];
        phonemeLength[i + 1] = phonemeLength[i];
        stress[i + 1] = stress[i];
    }

    phonemeindex[position] = mem60;
    phonemeLength[position] = mem59;
    stress[position] = mem58;
}

signed int full_match(unsigned char sign1, unsigned char sign2)
{
    unsigned char Y = 0;
    do {
        // GET FIRST CHARACTER AT POSITION Y IN signInputTable
        // --> should change name to PhonemeNameTable1
        unsigned char A = signInputTable1[Y];

        if (A == sign1) {
            A = signInputTable2[Y];
            // NOT A SPECIAL AND MATCHES SECOND CHARACTER?
            if ((A != '*') && (A == sign2)) return Y;
        }
    } while (++Y != 81);
    return -1;
}

signed int wild_match(unsigned char sign1)
{
    signed int Y = 0;
    do {
        if (signInputTable2[Y] == '*') {
            if (signInputTable1[Y] == sign1) return Y;
        }
    } while (++Y != 81);
    return -1;
}

// The input[] buffer contains a string of phonemes and stress markers along
// the lines of:
//
//     DHAX KAET IHZ AH5GLIY. <0x9B>
//
// The byte 0x9B marks the end of the buffer. Some phonemes are 2 bytes
// long, such as "DH" and "AX". Others are 1 byte long, such as "T" and "Z".
// There are also stress markers, such as "5" and ".".
//
// The first character of the phonemes are stored in the table signInputTable1[].
// The second character of the phonemes are stored in the table signInputTable2[].
// The stress characters are arranged in low to high stress order in stressInputTable[].
//
// The following process is used to parse the input[] buffer:
//
// Repeat until the <0x9B> character is reached:
//
//        First, a search is made for a 2 character match for phonemes that do not
//        end with the '*' (wildcard) character. On a match, the index of the phoneme
//        is added to phonemeIndex[] and the buffer position is advanced 2 bytes.
//
//        If this fails, a search is made for a 1 character match against all
//        phoneme names ending with a '*' (wildcard). If this succeeds, the
//        phoneme is added to phonemeIndex[] and the buffer position is advanced
//        1 byte.
//
//        If this fails, search for a 1 character match in the stressInputTable[].
//        If this succeeds, the stress value is placed in the last stress[] table
//        at the same index of the last added phoneme, and the buffer position is
//        advanced by 1 byte.
//
//        If this fails, return a 0.
//
// On success:
//
//    1. phonemeIndex[] will contain the index of all the phonemes.
//    2. The last index in phonemeIndex[] will be 255.
//    3. stress[] will contain the stress value for each phoneme

// input[] holds the string of phonemes, each two bytes wide
// signInputTable1[] holds the first character of each phoneme
// signInputTable2[] holds te second character of each phoneme
// phonemeIndex[] holds the indexes of the phonemes after parsing input[]
//
// The parser scans through the input[], finding the names of the phonemes
// by searching signInputTable1[] and signInputTable2[]. On a match, it
// copies the index of the phoneme into the phonemeIndexTable[].
//
// The character <0x9B> marks the end of text in input[]. When it is reached,
// the index 255 is placed at the end of the phonemeIndexTable[], and the
// function returns with a 1 indicating success.
int Parser1()
{
    unsigned char sign1;
    unsigned char position = 0;
    unsigned char srcpos = 0;

    memset(stress, 0, 256); // Clear the stress table.

    while ((sign1 = input[srcpos]) != 155) { // 155 (\233) is end of line marker
        signed int match;
        unsigned char sign2 = input[++srcpos];
        if ((match = full_match(sign1, sign2)) != -1) {
            // Matched both characters (no wildcards)
            phonemeindex[position++] = (unsigned char)match;
            ++srcpos; // Skip the second character of the input as we've matched it
        } else if ((match = wild_match(sign1)) != -1) {
            // Matched just the first character (with second character matching '*'
            phonemeindex[position++] = (unsigned char)match;
        } else {
            // Should be a stress character. Search through the
            // stress table backwards.
            match = 8; // End of stress table. FIXME: Don't hardcode.
            while ((sign1 != stressInputTable[match]) && (match > 0))
                --match;

            if (match == 0) return 0; // failure

            stress[position - 1] = (unsigned char)match; // Set stress for prior phoneme
        }
    } // while

    phonemeindex[position] = END;
    return 1;
}

// change phonemelength depedendent on stress
void SetPhonemeLength()
{
    int position = 0;
    while (phonemeindex[position] != 255) {
        unsigned char A = stress[position];
        if ((A == 0) || ((A & 128) != 0)) {
            phonemeLength[position] = phonemeLengthTable[phonemeindex[position]];
        } else {
            phonemeLength[position] = phonemeStressedLengthTable[phonemeindex[position]];
        }
        position++;
    }
}

void Code41240()
{
    unsigned char pos = 0;

    while (phonemeindex[pos] != END) {
        unsigned char index = phonemeindex[pos];

        if ((flags[index] & FLAG_STOPCONS)) {
            if ((flags[index] & FLAG_PLOSIVE)) {
                unsigned char A;
                unsigned char X = pos;
                while (!phonemeindex[++X])
                    ; /* Skip pause */
                A = phonemeindex[X];
                if (A != END) {
                    if ((flags[A] & 8) || (A == 36) || (A == 37)) {
                        ++pos;
                        continue;
                    } // '/H' '/X'
                }
            }
            Insert(pos + 1, index + 1, phonemeLengthTable[index + 1], stress[pos]);
            Insert(pos + 2, index + 2, phonemeLengthTable[index + 2], stress[pos]);
            pos += 2;
        }
        ++pos;
    }
}

void ChangeRule(unsigned char position, unsigned char mem60, const char* descr)
{
    phonemeindex[position] = 13; // rule;
    Insert(position + 1, mem60, 0, stress[position]);
}

// Rewrites the phonemes using the following rules:
//
//       <DIPTHONG ENDING WITH WX> -> <DIPTHONG ENDING WITH WX> WX
//       <DIPTHONG NOT ENDING WITH WX> -> <DIPTHONG NOT ENDING WITH WX> YX
//       UL -> AX L
//       UM -> AX M
//       <STRESSED VOWEL> <SILENCE> <STRESSED VOWEL> -> <STRESSED VOWEL> <SILENCE> Q <VOWEL>
//       T R -> CH R
//       D R -> J R
//       <VOWEL> R -> <VOWEL> RX
//       <VOWEL> L -> <VOWEL> LX
//       G S -> G Z
//       K <VOWEL OR DIPTHONG NOT ENDING WITH IY> -> KX <VOWEL OR DIPTHONG NOT ENDING WITH IY>
//       G <VOWEL OR DIPTHONG NOT ENDING WITH IY> -> GX <VOWEL OR DIPTHONG NOT ENDING WITH IY>
//       S P -> S B
//       S T -> S D
//       S K -> S G
//       S KX -> S GX
//       <ALVEOLAR> UW -> <ALVEOLAR> UX
//       CH -> CH CH' (CH requires two phonemes to represent it)
//       J -> J J' (J requires two phonemes to represent it)
//       <UNSTRESSED VOWEL> T <PAUSE> -> <UNSTRESSED VOWEL> DX <PAUSE>
//       <UNSTRESSED VOWEL> D <PAUSE>  -> <UNSTRESSED VOWEL> DX <PAUSE>

void rule_alveolar_uw(unsigned char X)
{
    // ALVEOLAR flag set?
    if (flags[phonemeindex[X - 1]] & FLAG_ALVEOLAR) {
        phonemeindex[X] = 16;
    }
}

void rule_ch(unsigned char X)
{
    Insert(X + 1, 43, 0, stress[X]);
}

void rule_j(unsigned char X)
{
    Insert(X + 1, 45, 0, stress[X]);
}

void rule_g(unsigned char pos)
{
    // G <VOWEL OR DIPTHONG NOT ENDING WITH IY> -> GX <VOWEL OR DIPTHONG NOT ENDING WITH IY>
    // Example: GO

    unsigned char index = phonemeindex[pos + 1];

    // If dipthong ending with YX, move continue processing next phoneme
    if ((index != 255) && ((flags[index] & FLAG_DIP_YX) == 0)) {
        // replace G with GX and continue processing next phoneme
        phonemeindex[pos] = 63; // 'GX'
    }
}

void change(unsigned char pos, unsigned char val, const char* rule)
{
    phonemeindex[pos] = val;
}

void rule_dipthong(unsigned char p, unsigned short pf, unsigned char pos)
{
    // <DIPTHONG ENDING WITH WX> -> <DIPTHONG ENDING WITH WX> WX
    // <DIPTHONG NOT ENDING WITH WX> -> <DIPTHONG NOT ENDING WITH WX> YX
    // Example: OIL, COW

    // If ends with IY, use YX, else use WX
    unsigned char A = (pf & FLAG_DIP_YX) ? 21 : 20; // 'WX' = 20 'YX' = 21

    // Insert at WX or YX following, copying the stress
    Insert(pos + 1, A, 0, stress[pos]);

    if (p == 53)
        rule_alveolar_uw(pos); // Example: NEW, DEW, SUE, ZOO, THOO, TOO
    else if (p == 42)
        rule_ch(pos); // Example: CHEW
    else if (p == 44)
        rule_j(pos); // Example: JAY
}

void Parser2()
{
    unsigned char pos = 0; // mem66;
    unsigned char p;

    while ((p = phonemeindex[pos]) != END) {
        unsigned short pf;
        unsigned char prior;

        if (p == 0) { // Is phoneme pause?
            ++pos;
            continue;
        }

        pf = flags[p];
        prior = phonemeindex[pos - 1];

        if ((pf & FLAG_DIPTHONG))
            rule_dipthong(p, pf, pos);
        else if (p == 78)
            ChangeRule(pos, 24, "UL -> AX L"); // Example: MEDDLE
        else if (p == 79)
            ChangeRule(pos, 27, "UM -> AX M"); // Example: ASTRONOMY
        else if (p == 80)
            ChangeRule(pos, 28, "UN -> AX N"); // Example: FUNCTION
        else if ((pf & FLAG_VOWEL) && stress[pos]) {
            // RULE:
            //       <STRESSED VOWEL> <SILENCE> <STRESSED VOWEL> -> <STRESSED VOWEL> <SILENCE> Q <VOWEL>
            // EXAMPLE: AWAY EIGHT
            if (!phonemeindex[pos + 1]) { // If following phoneme is a pause, get next
                p = phonemeindex[pos + 2];
                if (p != END && (flags[p] & FLAG_VOWEL) && stress[pos + 2]) {
                    Insert(pos + 2, 31, 0, 0); // 31 = 'Q'
                }
            }
        } else if (p == pR) { // RULES FOR PHONEMES BEFORE R
            if (prior == pT)
                change(pos - 1, 42, "T R -> CH R"); // Example: TRACK
            else if (prior == pD)
                change(pos - 1, 44, "D R -> J R"); // Example: DRY
            else if (flags[prior] & FLAG_VOWEL)
                change(pos, 18, "<VOWEL> R -> <VOWEL> RX"); // Example: ART
        } else if (p == 24 && (flags[prior] & FLAG_VOWEL))
            change(pos, 19, "<VOWEL> L -> <VOWEL> LX"); // Example: ALL
        else if (prior == 60 && p == 32) { // 'G' 'S'
            // Can't get to fire -
            //       1. The G -> GX rule intervenes
            //       2. Reciter already replaces GS -> GZ
            change(pos, 38, "G S -> G Z");
        } else if (p == 60)
            rule_g(pos);
        else {
            if (p == 72) { // 'K'
                // K <VOWEL OR DIPTHONG NOT ENDING WITH IY> -> KX <VOWEL OR DIPTHONG NOT ENDING WITH IY>
                // Example: COW
                unsigned char Y = phonemeindex[pos + 1];
                // If at end, replace current phoneme with KX
                if ((flags[Y] & FLAG_DIP_YX) == 0 || Y == END) { // VOWELS AND DIPTHONGS ENDING WITH IY SOUND flag set?
                    change(pos, 75, "K <VOWEL OR DIPTHONG NOT ENDING WITH IY> -> KX <VOWEL OR DIPTHONG NOT ENDING WITH IY>");
                    p = 75;
                    pf = flags[p];
                }
            }

            // Replace with softer version?
            if ((flags[p] & FLAG_PLOSIVE) && (prior == 32)) { // 'S'
                // RULE:
                //      S P -> S B
                //      S T -> S D
                //      S K -> S G
                //      S KX -> S GX
                // Examples: SPY, STY, SKY, SCOWL

                phonemeindex[pos] = p - 12;
            } else if (!(pf & FLAG_PLOSIVE)) {
                p = phonemeindex[pos];
                if (p == 53)
                    rule_alveolar_uw(pos); // Example: NEW, DEW, SUE, ZOO, THOO, TOO
                else if (p == 42)
                    rule_ch(pos); // Example: CHEW
                else if (p == 44)
                    rule_j(pos); // Example: JAY
            }

            if (p == 69 || p == 57) { // 'T', 'D'
                // RULE: Soften T following vowel
                // NOTE: This rule fails for cases such as "ODD"
                //       <UNSTRESSED VOWEL> T <PAUSE> -> <UNSTRESSED VOWEL> DX <PAUSE>
                //       <UNSTRESSED VOWEL> D <PAUSE>  -> <UNSTRESSED VOWEL> DX <PAUSE>
                // Example: PARTY, TARDY
                if (flags[phonemeindex[pos - 1]] & FLAG_VOWEL) {
                    p = phonemeindex[pos + 1];
                    if (!p) p = phonemeindex[pos + 2];
                    if ((flags[p] & FLAG_VOWEL) && !stress[pos + 1]) change(pos, 30, "Soften T or D following vowel or ER and preceding a pause -> DX");
                }
            }
        }
        pos++;
    } // while
}

// Applies various rules that adjust the lengths of phonemes
//
//         Lengthen <FRICATIVE> or <VOICED> between <VOWEL> and <PUNCTUATION> by 1.5
//         <VOWEL> <RX | LX> <CONSONANT> - decrease <VOWEL> length by 1
//         <VOWEL> <UNVOICED PLOSIVE> - decrease vowel by 1/8th
//         <VOWEL> <UNVOICED CONSONANT> - increase vowel by 1/2 + 1
//         <NASAL> <STOP CONSONANT> - set nasal = 5, consonant = 6
//         <VOICED STOP CONSONANT> {optional silence} <STOP CONSONANT> - shorten both to 1/2 + 1
//         <LIQUID CONSONANT> <DIPTHONG> - decrease by 2
//
void AdjustLengths()
{
    // LENGTHEN VOWELS PRECEDING PUNCTUATION
    //
    // Search for punctuation. If found, back up to the first vowel, then
    // process all phonemes between there and up to (but not including) the punctuation.
    // If any phoneme is found that is a either a fricative or voiced, the duration is
    // increased by (length * 1.5) + 1

    // loop index
    {
        unsigned char X = 0;
        unsigned char index;

        while ((index = phonemeindex[X]) != END) {
            unsigned char loopIndex;

            // not punctuation?
            if ((flags[index] & FLAG_PUNCT) == 0) {
                ++X;
                continue;
            }

            loopIndex = X;

            while (--X && !(flags[phonemeindex[X]] & FLAG_VOWEL))
                ; // back up while not a vowel
            if (X == 0) break;

            do {
                // test for vowel
                index = phonemeindex[X];

                // test for fricative/unvoiced or not voiced
                if (!(flags[index] & FLAG_FRICATIVE) || (flags[index] & FLAG_VOICED)) { // nochmal berprfen
                    unsigned char A = phonemeLength[X];
                    // change phoneme length to (length * 1.5) + 1
                    phonemeLength[X] = (A >> 1) + A + 1;
                }
            } while (++X != loopIndex);
            X++;
        } // while
    }

    // Similar to the above routine, but shorten vowels under some circumstances

    // Loop through all phonemes
    unsigned char loopIndex = 0;
    unsigned char index;

    while ((index = phonemeindex[loopIndex]) != END) {
        unsigned char X = loopIndex;

        if (flags[index] & FLAG_VOWEL) {
            index = phonemeindex[loopIndex + 1];
            if (!(flags[index] & FLAG_CONSONANT)) {
                if ((index == 18) || (index == 19)) { // 'RX', 'LX'
                    index = phonemeindex[loopIndex + 2];
                    if ((flags[index] & FLAG_CONSONANT)) {
                        phonemeLength[loopIndex]--;
                    }
                }
            } else { // Got here if not <VOWEL>
                unsigned short flag = (index == END) ? 65 : flags[index]; // 65 if end marker

                if (!(flag & FLAG_VOICED)) { // Unvoiced
                    // *, .*, ?*, ,*, -*, DX, S*, SH, F*, TH, /H, /X, CH, P*, T*, K*, KX
                    if ((flag & FLAG_PLOSIVE)) { // unvoiced plosive
                        // RULE: <VOWEL> <UNVOICED PLOSIVE>
                        // <VOWEL> <P*, T*, K*, KX>
                        phonemeLength[loopIndex] -= (phonemeLength[loopIndex] >> 3);
                    }
                } else {
                    unsigned char A;
                    // decrease length
                    A = phonemeLength[loopIndex];
                    phonemeLength[loopIndex] = (A >> 2) + A + 1; // 5/4*A + 1
                }
            }
        } else if ((flags[index] & FLAG_NASAL) != 0) { // nasal?
            // RULE: <NASAL> <STOP CONSONANT>
            //       Set punctuation length to 6
            //       Set stop consonant length to 5
            index = phonemeindex[++X];
            if (index != END && (flags[index] & FLAG_STOPCONS)) {
                phonemeLength[X] = 6; // set stop consonant length to 6
                phonemeLength[X - 1] = 5; // set nasal length to 5
            }
        } else if ((flags[index] & FLAG_STOPCONS)) { // (voiced) stop consonant?
            // RULE: <VOICED STOP CONSONANT> {optional silence} <STOP CONSONANT>
            //       Shorten both to (length/2 + 1)

            // move past silence
            while ((index = phonemeindex[++X]) == 0)
                ;

            if (index != END && (flags[index] & FLAG_STOPCONS)) {
                // FIXME, this looks wrong?
                // RULE: <UNVOICED STOP CONSONANT> {optional silence} <STOP CONSONANT>
                phonemeLength[X] = (phonemeLength[X] >> 1) + 1;
                phonemeLength[loopIndex] = (phonemeLength[loopIndex] >> 1) + 1;
                X = loopIndex;
            }
        } else if ((flags[index] & FLAG_LIQUIC)) { // liquic consonant?
            // RULE: <VOICED NON-VOWEL> <DIPTHONG>
            //       Decrease <DIPTHONG> by 2
            index = phonemeindex[X - 1]; // prior phoneme;

            phonemeLength[X] -= 2; // 20ms
        }

        ++loopIndex;
    }
}

void AddInflection(unsigned char mem48, unsigned char X);

//return = hibyte(mem39212*mem39213) <<  1
unsigned char trans(unsigned char a, unsigned char b)
{
    return (((unsigned int)a * b) >> 8) << 1;
}

//timetable for more accurate c64 simulation
static const int timetable[5][5] =
{
	{162, 167, 167, 127, 128},
	{226, 60, 60, 0, 0},
	{225, 60, 59, 0, 0},
	{200, 0, 0, 54, 55},
	{199, 0, 0, 54, 54}
};

void Output(int index, unsigned char A)
{
	static unsigned oldtimetableindex = 0;
	int k;
	bufferpos += timetable[oldtimetableindex][index];
	oldtimetableindex = index;
	// write a little bit in advance
	for(k=0; k<5; k++)
		buffer[bufferpos/50 + k] = (A & 15)*16;
}


static unsigned char RenderVoicedSample(unsigned short hi, unsigned char off, unsigned char phase1)
{
	do {
		unsigned char bit = 8;
		unsigned char sample = sampleTable[hi+off];
		do {
			if ((sample & 128) != 0) Output(3, 26);
			else Output(4, 6);
			sample <<= 1;
		} while(--bit != 0);
		off++;
	} while (++phase1 != 0);
	return off;
}

static void RenderUnvoicedSample(unsigned short hi, unsigned char off, unsigned char mem53)
{
    do {
        unsigned char bit = 8;
        unsigned char sample = sampleTable[hi+off];
        do {
            if ((sample & 128) != 0) Output(2, 5);
            else Output(1, mem53);
            sample <<= 1;
        } while (--bit != 0);
    } while (++off != 0);
}



// -------------------------------------------------------------------------
//Code48227
// Render a sampled sound from the sampleTable.
//
//   Phoneme   Sample Start   Sample End
//   32: S*    15             255
//   33: SH    257            511
//   34: F*    559            767
//   35: TH    583            767
//   36: /H    903            1023
//   37: /X    1135           1279
//   38: Z*    84             119
//   39: ZH    340            375
//   40: V*    596            639
//   41: DH    596            631
//
//   42: CH
//   43: **    399            511
//
//   44: J*
//   45: **    257            276
//   46: **
// 
//   66: P*
//   67: **    743            767
//   68: **
//
//   69: T*
//   70: **    231            255
//   71: **
//
// The SampledPhonemesTable[] holds flags indicating if a phoneme is
// voiced or not. If the upper 5 bits are zero, the sample is voiced.
//
// Samples in the sampleTable are compressed, with bits being converted to
// bytes from high bit to low, as follows:
//
//   unvoiced 0 bit   -> X
//   unvoiced 1 bit   -> 5
//
//   voiced 0 bit     -> 6
//   voiced 1 bit     -> 24
//
// Where X is a value from the table:
//
//   { 0x18, 0x1A, 0x17, 0x17, 0x17 };
//
// The index into this table is determined by masking off the lower
// 3 bits from the SampledPhonemesTable:
//
//        index = (SampledPhonemesTable[i] & 7) - 1;
//
// For voices samples, samples are interleaved between voiced output.


void RenderSample(unsigned char *mem66, unsigned char consonantFlag, unsigned char mem49)
{     
	// mem49 == current phoneme's index

	// mask low three bits and subtract 1 get value to 
	// convert 0 bits on unvoiced samples.
	unsigned char hibyte = (consonantFlag & 7)-1;
	
	// determine which offset to use from table { 0x18, 0x1A, 0x17, 0x17, 0x17 }
	// T, S, Z                0          0x18
	// CH, J, SH, ZH          1          0x1A
	// P, F*, V, TH, DH       2          0x17
	// /H                     3          0x17
	// /X                     4          0x17

    unsigned short hi = hibyte*256;
	// voiced sample?
	unsigned char pitchl = consonantFlag & 248;
	if(pitchl == 0) {
        // voiced phoneme: Z*, ZH, V*, DH
		pitchl = pitches[mem49] >> 4;
        *mem66 = RenderVoicedSample(hi, *mem66, pitchl ^ 255);
	}
	else
		RenderUnvoicedSample(hi, pitchl^255, tab48426[hibyte]);
}



// CREATE FRAMES
//
// The length parameter in the list corresponds to the number of frames
// to expand the phoneme to. Each frame represents 10 milliseconds of time.
// So a phoneme with a length of 7 = 7 frames = 70 milliseconds duration.
//
// The parameters are copied from the phoneme to the frame verbatim.
//
static void CreateFrames()
{
	unsigned char X = 0;
    unsigned int i = 0;
    while(i < 256) {
        // get the phoneme at the index
        unsigned char phoneme = phonemeIndexOutput[i];
		unsigned char phase1;
		unsigned phase2;
	
        // if terminal phoneme, exit the loop
        if (phoneme == 255) break;
	
        if (phoneme == PHONEME_PERIOD)   AddInflection(RISING_INFLECTION, X);
        else if (phoneme == PHONEME_QUESTION) AddInflection(FALLING_INFLECTION, X);

        // get the stress amount (more stress = higher pitch)
        phase1 = tab47492[stressOutput[i] + 1];
	
        // get number of frames to write
        phase2 = phonemeLengthOutput[i];
	
        // copy from the source to the frames list
        do {
            frequency1[X] = freq1data[phoneme];     // F1 frequency
            frequency2[X] = freq2data[phoneme];     // F2 frequency
            frequency3[X] = freq3data[phoneme];     // F3 frequency
            amplitude1[X] = ampl1data[phoneme];     // F1 amplitude
            amplitude2[X] = ampl2data[phoneme];     // F2 amplitude
            amplitude3[X] = ampl3data[phoneme];     // F3 amplitude
            sampledConsonantFlag[X] = sampledConsonantFlags[phoneme];        // phoneme data for sampled consonants
            pitches[X] = pitch + phase1;      // pitch
            ++X;
        } while(--phase2 != 0);
        
        ++i;
    }
}


// RESCALE AMPLITUDE
//
// Rescale volume from a linear scale to decibels.
//
void RescaleAmplitude() 
{
    int i;
    for(i=255; i>=0; i--)
        {
            amplitude1[i] = amplitudeRescale[amplitude1[i]];
            amplitude2[i] = amplitudeRescale[amplitude2[i]];
            amplitude3[i] = amplitudeRescale[amplitude3[i]];
        }
}



// ASSIGN PITCH CONTOUR
//
// This subtracts the F1 frequency from the pitch to create a
// pitch contour. Without this, the output would be at a single
// pitch level (monotone).

void AssignPitchContour()
{	
    int i;
    for(i=0; i<256; i++) {
        // subtract half the frequency of the formant 1.
        // this adds variety to the voice
        pitches[i] -= (frequency1[i] >> 1);
    }
}


// RENDER THE PHONEMES IN THE LIST
//
// The phoneme list is converted into sound through the steps:
//
// 1. Copy each phoneme <length> number of times into the frames list,
//    where each frame represents 10 milliseconds of sound.
//
// 2. Determine the transitions lengths between phonemes, and linearly
//    interpolate the values across the frames.
//
// 3. Offset the pitches by the fundamental frequency.
//
// 4. Render the each frame.
void Render()
{
    unsigned char t;

	if (phonemeIndexOutput[0] == 255) return; //exit if no data

    CreateFrames();
    t = CreateTransitions();

    AssignPitchContour();
    RescaleAmplitude();

    ProcessFrames(t);
}

// CREATE TRANSITIONS
//
// Linear transitions are now created to smoothly connect each
// phoeneme. This transition is spread between the ending frames
// of the old phoneme (outBlendLength), and the beginning frames 
// of the new phoneme (inBlendLength).
//
// To determine how many frames to use, the two phonemes are 
// compared using the blendRank[] table. The phoneme with the 
// smaller score is used. In case of a tie, a blend of each is used:
//
//      if blendRank[phoneme1] ==  blendRank[phomneme2]
//          // use lengths from each phoneme
//          outBlendFrames = outBlend[phoneme1]
//          inBlendFrames = outBlend[phoneme2]
//      else if blendRank[phoneme1] < blendRank[phoneme2]
//          // use lengths from first phoneme
//          outBlendFrames = outBlendLength[phoneme1]
//          inBlendFrames = inBlendLength[phoneme1]
//      else
//          // use lengths from the second phoneme
//          // note that in and out are swapped around!
//          outBlendFrames = inBlendLength[phoneme2]
//          inBlendFrames = outBlendLength[phoneme2]
//
//  Blend lengths can't be less than zero.
//
// For most of the parameters, SAM interpolates over the range of the last
// outBlendFrames-1 and the first inBlendFrames.
//
// The exception to this is the Pitch[] parameter, which is interpolates the
// pitch from the center of the current phoneme to the center of the next
// phoneme.

// From render.c
extern unsigned char phonemeIndexOutput[60]; //tab47296
extern unsigned char phonemeLengthOutput[60]; //tab47416

// from RenderTabs.h
extern unsigned char blendRank[];
extern unsigned char outBlendLength[];
extern unsigned char inBlendLength[];
extern unsigned char pitches[];

extern unsigned char frequency1[256];
extern unsigned char frequency2[256];
extern unsigned char frequency3[256];

extern unsigned char amplitude1[256];
extern unsigned char amplitude2[256];
extern unsigned char amplitude3[256];

//written by me because of different table positions.
// mem[47] = ...
// 168=pitches
// 169=frequency1
// 170=frequency2
// 171=frequency3
// 172=amplitude1
// 173=amplitude2
// 174=amplitude3
unsigned char Read(unsigned char p, unsigned char Y)
{
	switch(p)
	{
	case 168: return pitches[Y];
	case 169: return frequency1[Y];
	case 170: return frequency2[Y];
	case 171: return frequency3[Y];
	case 172: return amplitude1[Y];
	case 173: return amplitude2[Y];
	case 174: return amplitude3[Y];
	default: 
		printf("Error reading from tables");
		return 0;
	}
}

void Write(unsigned char p, unsigned char Y, unsigned char value)
{
	switch(p)
	{
	case 168: pitches[Y]    = value; return;
	case 169: frequency1[Y] = value; return;
	case 170: frequency2[Y] = value; return;
	case 171: frequency3[Y] = value; return;
	case 172: amplitude1[Y] = value; return;
	case 173: amplitude2[Y] = value; return;
	case 174: amplitude3[Y] = value; return;
	default:
		printf("Error writing to tables\n");
		return;
	}
}


// linearly interpolate values
void interpolate(unsigned char width, unsigned char table, unsigned char frame, char mem53)
{
    unsigned char sign      = (mem53 < 0);
    unsigned char remainder = abs(mem53) % width;
    unsigned char div       = mem53 / width;

    unsigned char error = 0;
    unsigned char pos   = width;
    unsigned char val   = Read(table, frame) + div; 

    while(--pos) {
        error += remainder;
        if (error >= width) { // accumulated a whole integer error, so adjust output
            error -= width;
            if (sign) val--;
            else if (val) val++; // if input is 0, we always leave it alone
        }
        Write(table, ++frame, val); // Write updated value back to next frame.
        val += div;
    }
}

void interpolate_pitch(unsigned char pos, unsigned char mem49, unsigned char phase3) {
    // unlike the other values, the pitches[] interpolates from 
    // the middle of the current phoneme to the middle of the 
    // next phoneme
        
    // half the width of the current and next phoneme
    unsigned char cur_width  = phonemeLengthOutput[pos] / 2;
    unsigned char next_width = phonemeLengthOutput[pos+1] / 2;
    // sum the values
    unsigned char width = cur_width + next_width;
    char pitch = pitches[next_width + mem49] - pitches[mem49- cur_width];
    interpolate(width, 168, phase3, pitch);
}


static unsigned char CreateTransitions()
{
	unsigned char mem49 = 0; 
	unsigned char pos = 0;
	while(1) {
		unsigned char next_rank;
		unsigned char rank;
		unsigned char speedcounter;
		unsigned char phase1;
		unsigned char phase2;
		unsigned char phase3;
		unsigned char transition;

		unsigned char phoneme      = phonemeIndexOutput[pos];
		unsigned char next_phoneme = phonemeIndexOutput[pos+1];

		if (next_phoneme == 255) break; // 255 == end_token

        // get the ranking of each phoneme
		next_rank = blendRank[next_phoneme];
		rank      = blendRank[phoneme];
		
		// compare the rank - lower rank value is stronger
		if (rank == next_rank) {
            // same rank, so use out blend lengths from each phoneme
			phase1 = outBlendLength[phoneme];
			phase2 = outBlendLength[next_phoneme];
		} else if (rank < next_rank) {
            // next phoneme is stronger, so us its blend lengths
			phase1 = inBlendLength[next_phoneme];
			phase2 = outBlendLength[next_phoneme];
		} else {
            // current phoneme is stronger, so use its blend lengths
            // note the out/in are swapped
			phase1 = outBlendLength[phoneme];
			phase2 = inBlendLength[phoneme];
		}

		mem49 += phonemeLengthOutput[pos]; 

		speedcounter = mem49 + phase2;
		phase3       = mem49 - phase1;
		transition   = phase1 + phase2; // total transition?
		
		if (((transition - 2) & 128) == 0) {
            unsigned char table = 169;
            interpolate_pitch(pos, mem49, phase3);
            while (table < 175) {
                // tables:
                // 168  pitches[]
                // 169  frequency1
                // 170  frequency2
                // 171  frequency3
                // 172  amplitude1
                // 173  amplitude2
                // 174  amplitude3
                
                char value = Read(table, speedcounter) - Read(table, phase3);
                interpolate(transition, table, phase3, value);
                table++;
            }
        }
		++pos;
	} 

    // add the length of this phoneme
    return mem49 + phonemeLengthOutput[pos];
}

static void CombineGlottalAndFormants(unsigned char phase1, unsigned char phase2, unsigned char phase3, unsigned char Y)
{
    unsigned int tmp;

    tmp   = multtable[sinus[phase1]     | amplitude1[Y]];
    tmp  += multtable[sinus[phase2]     | amplitude2[Y]];
    tmp  += tmp > 255 ? 1 : 0; // if addition above overflows, we for some reason add one;
    tmp  += multtable[rectangle[phase3] | amplitude3[Y]];
    tmp  += 136;
    tmp >>= 4; // Scale down to 0..15 range of C64 audio.
            
    Output(0, tmp & 0xf);
}

// PROCESS THE FRAMES
//
// In traditional vocal synthesis, the glottal pulse drives filters, which
// are attenuated to the frequencies of the formants.
//
// SAM generates these formants directly with sin and rectangular waves.
// To simulate them being driven by the glottal pulse, the waveforms are
// reset at the beginning of each glottal pulse.
//
static void ProcessFrames(unsigned char mem48)
{
    unsigned char speedcounter = 72;
	unsigned char phase1 = 0;
    unsigned char phase2 = 0;
	unsigned char phase3 = 0;
    unsigned char mem66 = 0; //!! was not initialized
    
    unsigned char Y = 0;

    unsigned char glottal_pulse = pitches[0];
    unsigned char mem38 = glottal_pulse - (glottal_pulse >> 2); // mem44 * 0.75

	while(mem48) {
		unsigned char flags = sampledConsonantFlag[Y];
		
		// unvoiced sampled phoneme?
        if(flags & 248) {
			RenderSample(&mem66, flags,Y);
			// skip ahead two in the phoneme buffer
			Y += 2;
			mem48 -= 2;
            speedcounter = speed;
		} else {
            CombineGlottalAndFormants(phase1, phase2, phase3, Y);

			speedcounter--;
			if (speedcounter == 0) { 
                Y++; //go to next amplitude
                // decrement the frame count
                mem48--;
                if(mem48 == 0) return;
                speedcounter = speed;
            }
         
            --glottal_pulse;
		
            if(glottal_pulse != 0) {
                // not finished with a glottal pulse

                --mem38;
                // within the first 75% of the glottal pulse?
                // is the count non-zero and the sampled flag is zero?
                if((mem38 != 0) || (flags == 0)) {
                    // reset the phase of the formants to match the pulse
                    phase1 += frequency1[Y];
                    phase2 += frequency2[Y];
                    phase3 += frequency3[Y];
                    continue;
                }
                
                // voiced sampled phonemes interleave the sample with the
                // glottal pulse. The sample flag is non-zero, so render
                // the sample for the phoneme.
                RenderSample(&mem66, flags,Y);
            }
        }

        glottal_pulse = pitches[Y];
        mem38 = glottal_pulse - (glottal_pulse>>2); // mem44 * 0.75

        // reset the formant wave generators to keep them in 
        // sync with the glottal pulse
        phase1 = 0;
        phase2 = 0;
        phase3 = 0;
	}
}



// Create a rising or falling inflection 30 frames prior to 
// index X. A rising inflection is used for questions, and 
// a falling inflection is used for statements.

void AddInflection(unsigned char inflection, unsigned char pos)
{
    unsigned char A;
    // store the location of the punctuation
	unsigned char end = pos;

    if (pos < 30) pos = 0;
    else pos -= 30;

	// FIXME: Explain this fix better, it's not obvious
	// ML : A =, fixes a problem with invalid pitch with '.'
	while( (A = pitches[pos]) == 127) ++pos;

    while (pos != end) {
        // add the inflection direction
        A += inflection;
	
        // set the inflection
        pitches[pos] = A;

        while ((++pos != end) && pitches[pos] == 255);
    } 
}

/*
    SAM's voice can be altered by changing the frequencies of the
    mouth formant (F1) and the throat formant (F2). Only the voiced
    phonemes (5-29 and 48-53) are altered.
*/
void SetMouthThroat(unsigned char mouth, unsigned char throat)
{
	// mouth formants (F1) 5..29
	static const unsigned char mouthFormants5_29[30] = {
		0, 0, 0, 0, 0, 10,
		14, 19, 24, 27, 23, 21, 16, 20, 14, 18, 14, 18, 18,
		16, 13, 15, 11, 18, 14, 11, 9, 6, 6, 6};

	// throat formants (F2) 5..29
	static const unsigned char throatFormants5_29[30] = {
	255, 255,
	255, 255, 255, 84, 73, 67, 63, 40, 44, 31, 37, 45, 73, 49,
	36, 30, 51, 37, 29, 69, 24, 50, 30, 24, 83, 46, 54, 86,
    };

	// there must be no zeros in this 2 tables
	// formant 1 frequencies (mouth) 48..53
	static const unsigned char mouthFormants48_53[6] = {19, 27, 21, 27, 18, 13};
       
	// formant 2 frequencies (throat) 48..53
	static const unsigned char throatFormants48_53[6] = {72, 39, 31, 43, 30, 34};

	unsigned char newFrequency = 0;
	unsigned char pos = 5;

	// recalculate formant frequencies 5..29 for the mouth (F1) and throat (F2)
	while(pos < 30)
	{
		// recalculate mouth frequency
		unsigned char initialFrequency = mouthFormants5_29[pos];
		if (initialFrequency != 0) newFrequency = trans(mouth, initialFrequency);
		freq1data[pos] = newFrequency;
               
		// recalculate throat frequency
		initialFrequency = throatFormants5_29[pos];
		if(initialFrequency != 0) newFrequency = trans(throat, initialFrequency);
		freq2data[pos] = newFrequency;
		pos++;
	}

	// recalculate formant frequencies 48..53
	pos = 0;
    while(pos < 6) {
		// recalculate F1 (mouth formant)
		unsigned char initialFrequency = mouthFormants48_53[pos];
		freq1data[pos+48] = trans(mouth, initialFrequency);
           
		// recalculate F2 (throat formant)
		initialFrequency = throatFormants48_53[pos];
		freq2data[pos+48] = trans(throat, initialFrequency);
		pos++;
	}
}

unsigned char A, X;

static unsigned char inputtemp[256];   // secure copy of input tab36096

/* Retrieve flags for character at mem59-1 */
unsigned char Code37055(unsigned char npos, unsigned char mask)
{
	X = npos;
	return tab36376[inputtemp[X]] & mask;
}

unsigned int match(const char * str) {
    while (*str) {
        unsigned char ch = *str;
        A = inputtemp[X++];
        if (A != ch) return 0;
        ++str;
    }
    return 1;
}

unsigned char GetRuleByte(unsigned short mem62, unsigned char Y) {
	unsigned int address = mem62;
	if (mem62 >= 37541) {
		address -= 37541;
		return rules2[address+Y];
	}
	address -= 32000;
	return rules[address+Y];
}

int handle_ch2(unsigned char ch, unsigned char mem) {
    unsigned char tmp;
    X = mem;
    tmp = tab36376[inputtemp[mem]];
    if (ch == ' ') {
        if(tmp & 128) return 1;
    } else if (ch == '#') {
        if(!(tmp & 64)) return 1;
    } else if (ch == '.') {
        if(!(tmp & 8)) return 1;
    } else if (ch == '^') {
        if(!(tmp & 32)) return 1;
    } else return -1;
    return 0;
}


int handle_ch(unsigned char ch, unsigned char mem) {
    unsigned char tmp;
    X = mem;
    tmp = tab36376[inputtemp[X]];
    if (ch == ' ') {
        if ((tmp & 128) != 0) return 1;
    } else if (ch == '#') {
        if ((tmp & 64) == 0) return 1;
    } else if (ch == '.') {
        if((tmp & 8) == 0) return 1;
    } else if (ch == '&') {
        if((tmp & 16) == 0) {
            if (inputtemp[X] != 72) return 1;
            ++X;
        }
    } else if (ch == '^') {
        if ((tmp & 32) == 0) return 1;
    } else if (ch == '+') {
        X = mem;
        ch = inputtemp[X];
        if ((ch != 69) && (ch != 73) && (ch != 89)) return 1;
    } else return -1;
    return 0;
}


int TextToPhonemes(unsigned char *input) {
	unsigned char mem56;      //output position for phonemes
	unsigned char mem57;
	unsigned char mem58;
	unsigned char mem59;
	unsigned char mem60;
	unsigned char mem61;
	unsigned short mem62;     // memory position of current rule

	unsigned char mem64;      // position of '=' or current character
	unsigned char mem65;     // position of ')'
	unsigned char mem66;     // position of '('

	unsigned char Y;

	int r;

	inputtemp[0] = ' ';

	// secure copy of input
	// because input will be overwritten by phonemes
	X = 0;
	do {
		A = input[X] & 127;
		if ( A >= 112) A = A & 95;
		else if ( A >= 96) A = A & 79;
		inputtemp[++X] = A;
	} while (X < 255);
	inputtemp[255] = 27;
	mem56 = mem61 = 255;

pos36554:
    while (1) {
        while(1) {
            X = ++mem61;
            mem64 = inputtemp[X];
            if (mem64 == '[') {
                X = ++mem56;
                input[X] = 155;
                return 1;
            }
            
            if (mem64 != '.') break;
            X++;
            A = tab36376[inputtemp[X]] & 1;
            if(A != 0) break;
            mem56++;
            X = mem56;
            A = '.';
            input[X] = '.';
        }
        mem57 = tab36376[mem64];
        if((mem57&2) != 0) {
            mem62 = 37541;
            goto pos36700;
        }
        
        if(mem57 != 0) break;
        inputtemp[X] = ' ';
        X = ++mem56;
        if (X > 120) {
            input[X] = 155;
            return 1;
        }
        input[X] = 32;
    }

    if(!(mem57 & 128)) return 0;

	// go to the right rules for this character.
    X = mem64 - 'A';
    mem62 = tab37489[X] | (tab37515[X]<<8);

pos36700:
	// find next rule
	while ((GetRuleByte(++mem62, 0) & 128) == 0)
        ;
	Y = 0;
	while(GetRuleByte(mem62, ++Y) != '(')
        ;
	mem66 = Y;
    while(GetRuleByte(mem62, ++Y) != ')')
        ;
	mem65 = Y;
	while((GetRuleByte(mem62, ++Y) & 127) != '=')
        ;
	mem64 = Y;

	
	mem60 = X = mem61;
	// compare the string within the bracket
	Y = mem66 + 1;

	while(1) {
		if (GetRuleByte(mem62, Y) != inputtemp[X]) goto pos36700;
		if(++Y == mem65) break;
		mem60 = ++X;
	}

    // the string in the bracket is correct

	mem59 = mem61;

    while(1) {
		unsigned char ch;
		while(1) {
            mem66--;
            mem57 = GetRuleByte(mem62, mem66);
            if ((mem57 & 128) != 0) {
                mem58 = mem60;
                goto pos37184;
            }
            X = mem57 & 127;
            if ((tab36376[X] & 128) == 0) break;
            if (inputtemp[mem59-1] != mem57) goto pos36700;
            --mem59;
        }

        ch = mem57;

        r = handle_ch2(ch, mem59-1);
        if (r == -1) {
            switch (ch) {
            case '&':
                if (!Code37055(mem59-1,16)) {
                    if (inputtemp[X] != 'H') r = 1;
                    else {
                        A = inputtemp[--X];
                        if ((A != 'C') && (A != 'S')) r = 1;
                    }
                }
                break;
                
            case '@':
                if(!Code37055(mem59-1,4)) { 
                    A = inputtemp[X];
                    if (A != 72) r = 1;
                    if ((A != 84) && (A != 67) && (A != 83)) r = 1;
                }
                break;
            case '+':
                X = mem59;
                A = inputtemp[--X];
                if ((A != 'E') && (A != 'I') && (A != 'Y')) r = 1;
                break;
            case ':':
                while (Code37055(mem59-1,32)) --mem59;
                continue;
            default:
                return 0;
            }
        }

        if (r == 1) goto pos36700;

        mem59 = X;
    }

    do {
        X = mem58+1;
        if (inputtemp[X] == 'E') {
            if((tab36376[inputtemp[X+1]] & 128) != 0) {
                A = inputtemp[++X];
                if (A == 'L') {
                    if (inputtemp[++X] != 'Y') goto pos36700;
                } else if ((A != 'R') && (A != 'S') && (A != 'D') && !match("FUL")) goto pos36700;
            }
        } else {
            if (!match("ING")) goto pos36700;
            mem58 = X;
        }
        
pos37184:
        r = 0;
        do {
            while (1) {
                Y = mem65 + 1;
                if(Y == mem64) {
                    mem61 = mem60;
                    
                    while(1) {
                        mem57 = A = GetRuleByte(mem62, Y);
                        A = A & 127;
                        if (A != '=') input[++mem56] = A;
                        if ((mem57 & 128) != 0) goto pos36554;
                        Y++;
                    }
                }
                mem65 = Y;
                mem57 = GetRuleByte(mem62, Y);
                if((tab36376[mem57] & 128) == 0) break;
                if (inputtemp[mem58+1] != mem57) {
                    r = 1;
                    break;
                }
                ++mem58;
            }

            if (r == 0) {
                A = mem57;
                if (A == '@') {
                    if(Code37055(mem58+1, 4) == 0) {
                        A = inputtemp[X];
                        if ((A != 82) && (A != 84) && 
                            (A != 67) && (A != 83)) r = 1;
                    } else {
                        r = -2;
                    }
                } else if (A == ':') {
                    while (Code37055(mem58+1, 32)) mem58 = X;
                    r = -2;
                } else r = handle_ch(A, mem58+1);
            }

            if (r == 1) goto pos36700;
            if (r == -2) { 
                r = 0;
                continue;
            }
            if (r == 0) mem58 = X;
        } while (r == 0);
    } while (A == '%');
	return 0;
}
